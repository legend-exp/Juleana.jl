var documenterSearchIndex = {"docs":
[{"location":"packages/LegendTextIO/#LegendTextIO","page":"LegendTextIO","title":"LegendTextIO","text":"","category":"section"},{"location":"packages/LegendTextIO/","page":"LegendTextIO","title":"LegendTextIO","text":"Also see LegendTextIO on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendTextIO/#Modules","page":"LegendTextIO","title":"Modules","text":"","category":"section"},{"location":"packages/LegendTextIO/","page":"LegendTextIO","title":"LegendTextIO","text":"Modules = [LegendTextIO]\nOrder = [:module]","category":"page"},{"location":"packages/LegendTextIO/#Types-and-constants","page":"LegendTextIO","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendTextIO/","page":"LegendTextIO","title":"LegendTextIO","text":"Modules = [LegendTextIO]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendTextIO/#Functions-and-macros","page":"LegendTextIO","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendTextIO/","page":"LegendTextIO","title":"LegendTextIO","text":"Modules = [LegendTextIO]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendTextIO/#Documentation","page":"LegendTextIO","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendTextIO/","page":"LegendTextIO","title":"LegendTextIO","text":"Modules = [LegendTextIO]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendTextIO/#LegendTextIO.DarioHitsFile","page":"LegendTextIO","title":"LegendTextIO.DarioHitsFile","text":"DarioHitsFile(file::Union{IOStream, AbstractString}; batch_size::Integer=10)\n\nrepresents a .root.hits file given by MaGe's Dario output scheme. A DarioHitsFile can be iterated or read to yield events, which contain data on energy depositions, i.e. hits.\n\nA DarioHitsFile is also a Tables.jl compatible row table of events. batch_size determines the number of events grouped into partitions when Tables.partitions is used. To change the default of 10, see DARIO_HITS_BATCH_SIZE.\n\n\n\n\n\n","category":"type"},{"location":"packages/SolidStateDetectors/#SolidStateDetectors","page":"SolidStateDetectors","title":"SolidStateDetectors","text":"","category":"section"},{"location":"packages/SolidStateDetectors/","page":"SolidStateDetectors","title":"SolidStateDetectors","text":"See SolidStateDetectors on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendTestData/#LegendTestData","page":"LegendTestData","title":"LegendTestData","text":"","category":"section"},{"location":"packages/LegendTestData/","page":"LegendTestData","title":"LegendTestData","text":"Also see LegendTestData on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendTestData/#Modules","page":"LegendTestData","title":"Modules","text":"","category":"section"},{"location":"packages/LegendTestData/","page":"LegendTestData","title":"LegendTestData","text":"Modules = [LegendTestData]\nOrder = [:module]","category":"page"},{"location":"packages/LegendTestData/#Types-and-constants","page":"LegendTestData","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendTestData/","page":"LegendTestData","title":"LegendTestData","text":"Modules = [LegendTestData]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendTestData/#Functions-and-macros","page":"LegendTestData","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendTestData/","page":"LegendTestData","title":"LegendTestData","text":"Modules = [LegendTestData]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendTestData/#Documentation","page":"LegendTestData","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendTestData/","page":"LegendTestData","title":"LegendTestData","text":"Modules = [LegendTestData]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendTestData/#LegendTestData.legend_test_data_path-Tuple{}","page":"LegendTestData","title":"LegendTestData.legend_test_data_path","text":"legend_test_data_path()::AbstractString\n\nGet local path to the LEGEND test data set.\n\nWill download the test data version matching the current version of LegendTestData if not already present. The local copy of the test data is managed via DataDeps.jl.\n\nSet ENV[\"DATADEPS_ALWAYS_ACCEPT\"] = \"true\" to avoid interactive prompt asking for download permission.\n\n\n\n\n\n","category":"method"},{"location":"packages/BAT/#BAT","page":"BAT","title":"BAT","text":"","category":"section"},{"location":"packages/BAT/","page":"BAT","title":"BAT","text":"See BAT on GitHub and the full package documentation.","category":"page"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"","category":"section"},{"location":"packages/RadiationDetectorDSP/","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"Also see RadiationDetectorDSP on GitHub and the full package documentation.","category":"page"},{"location":"packages/RadiationDetectorDSP/#Modules","page":"RadiationDetectorDSP","title":"Modules","text":"","category":"section"},{"location":"packages/RadiationDetectorDSP/","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"Modules = [RadiationDetectorDSP]\nOrder = [:module]","category":"page"},{"location":"packages/RadiationDetectorDSP/#Types-and-constants","page":"RadiationDetectorDSP","title":"Types and constants","text":"","category":"section"},{"location":"packages/RadiationDetectorDSP/","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"Modules = [RadiationDetectorDSP]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/RadiationDetectorDSP/#Functions-and-macros","page":"RadiationDetectorDSP","title":"Functions and macros","text":"","category":"section"},{"location":"packages/RadiationDetectorDSP/","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"Modules = [RadiationDetectorDSP]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/RadiationDetectorDSP/#Documentation","page":"RadiationDetectorDSP","title":"Documentation","text":"","category":"section"},{"location":"packages/RadiationDetectorDSP/","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP","text":"Modules = [RadiationDetectorDSP]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.AbstractRadFIRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.AbstractRadFIRFilter","text":"abstract type AbstractRadFIRFilter <: AbstractRadLinearFilter\n\nAbstract type for FIR filters.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.AbstractRadIIRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.AbstractRadIIRFilter","text":"abstract type AbstractRadIIRFilter <: AbstractRadSigFilter{LinearFiltering}\n\nAbstract type for IIR filters.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.AbstractRadSigFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.AbstractRadSigFilter","text":"abstract type AbstractRadSigFilter{FT<:FilteringType} <: Function\n\nAbstract type for signal filters.\n\nFilters are callable as (flt::AbstractRadSigFilter)(input) and come with specialized broadcasting.\n\nSubtypes of AbstractRadSigFilter must implement\n\nfltinstance(flt::AbstractRadSigFilter, si::SamplingInfo)::[`AbstractRadSigFilterInstance`](@ref)\n\nInvertible filters should also implement\n\nInverseFunctions.inverse(flt::SomeFilter)\n\nNote that while a filter may have an inverse, it may, depending on the filter paramters, be very unstable in the presence of additional noise. Filters with a high-pass characteristic pass high-frequency noise, so their inverses pass such noise as well without amplifying it (substantially). Filters with a low-pass characteristic, on the other hand, attentuate high-frequency noise, so their inverses amplify such noise and are typically not useful to deconvolve signals in practical applications.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.AbstractRadSigFilterInstance","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.AbstractRadSigFilterInstance","text":"abstract type AbstractRadSigFilterInstance{FT<:FilteringType}\n\nAbstract type for signal filter instances. Filter instances are specilized to a specific length and numerical type of input and output.\n\nFilter instances are callable as (fi::SomeFilterInstance)(input) and come with specialized broadcasting.\n\nSubtypes of AbstractRadSigFilterInstance must implement\n\nRadiationDetectorDSP.rdfilt!(output, fi::SomeFilterInstance, input)\nRadiationDetectorDSP.flt_output_smpltype(fi::SomeFilterInstance)\nRadiationDetectorDSP.flt_input_smpltype(fi::SomeFilterInstance)\nRadiationDetectorDSP.flt_output_length(fi::SomeFilterInstance)\nRadiationDetectorDSP.flt_input_length(fi::SomeFilterInstance)\nRadiationDetectorDSP.flt_output_time_axis(fi::SomeFilterInstance, time::AbstractVector{<:RealQuantity})\n\nInvertible filter instances should implement\n\nInverseFunctions.inverse(fi::SomeFilterInstance)\n\nDefault methods are implemented for\n\nRadiationDetectorDSP.rdfilt(fi::AbstractRadSigFilterInstance, x::AbstractSamples)\nRadiationDetectorDSP.rdfilt(fi::AbstractRadSigFilterInstance, wf::RDWaveform)\nRadiationDetectorDSP.bc_rdfilt(fi::AbstractRadSigFilterInstance, inputs)\n\nThe default methods that operate on RadiationDetectorSignals.RDWaveforms require RadiationDetectorDSP.flt_output_time_axis.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.AbstractSamples","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.AbstractSamples","text":"const AbstractSamples{T<:RealQuantity} = AbstractVector{T}\n\nA vector of signal samples.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.ArrayOfSimilarSamples","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.ArrayOfSimilarSamples","text":"const ArrayOfSimilarSamples{T<:RealQuantity} = ArrayOfSimilarVectors{T}\n\nAn array of similar sample vectors.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.BiquadFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.BiquadFilter","text":"struct BiquadFilter{T<:RealQuantity} <: AbstractRadIIRFilter\n\nA biquad filter.\n\nConstructors:\n\nBiquadFilter(fields...)\n\nFields:\n\nb_012::Tuple{T, T, T} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real): Coefficients b0 to b2\na_12::Tuple{T, T} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real): Coefficients a1 to a2, a_0 equals one implicitly\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.CPUNormAdaptor","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.CPUNormAdaptor","text":"RadiationDetectorDSP.CPUNormAdaptor\n\nTo be used with Adapt.adapt.\n\nAdapt.adapt(RadiationDetectorDSP.CPUNormAdaptor, x) adapts x to reside on the CPU and tries to ensure that arrays are stored in column-major order.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.CRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.CRFilter","text":"struct CRFilter <: AbstractRadIIRFilter\n\nA first-order CR highpass filter.\n\nThe inverse filter is InvCRFilter, this is typically stable even in the presence of additional noise. This is because a CR filter passes high-frequency noise and so it's inverse passes such noise as well without amplifying it.\n\nConstructors:\n\nCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.CUSPChargeFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.CUSPChargeFilter","text":"struct CUSPChargeFilter <: AbstractRadFIRFilter\n\nCUSP filter.\n\nFor the definition the filter and a discussion of the filter properties, see\n\nConstructors:\n\nCUSPChargeFilter(; fields...)\n\nFields:\n\nsigma::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: equivalent of shaping time (τₛ) Default: 450\ntoplen::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: length of flat top (FT) Default: 10\ntau::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: decay constant of the exponential Default: 20\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: total length of the filter (L) Default: 100\nbeta::AbstractFloat: scaling factor Default: 100.0\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.ConvolutionFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.ConvolutionFilter","text":"struct ConvolutionFilter{T<:RealQuantity} <: AbstractRadFIRFilter\n\nA FIR filter defined by it's filter taps, applied via convolution with the input signal.\n\nConstructors:\n\nConvolutionFilter(fields...)\n\nFields:\n\nmethod::RadiationDetectorDSP.ConvolutionMethod: Convolution method\ncoeffs::AbstractVector{T} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real): Filter taps\noffset::Int64: Time axis offset\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.ConvolutionMethod","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.ConvolutionMethod","text":"abstract type ConvolutionMethod\n\nIndended as a type parameter to designate the behavior of a filter as linear or nonlinear.\n\nSubtypes are DirectConvolution and FFTConvolution.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.DNIMethod","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.DNIMethod","text":"abstract type DNIMethod\n\nAbstract type for denoising and interpolation methods.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.DifferentiatorFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.DifferentiatorFilter","text":"struct DifferentiatorFilter <: AbstractRadIIRFilter\n\nAn integrator filter. It's inverse is IntegratorFilter.\n\nConstructors:\n\nDifferentiatorFilter(fields...)\n\nFields:\n\ngain::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Filter gain\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.DirectConvolution","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.DirectConvolution","text":"DirectConvolution() isa ConvolutionMethod\n\nCompute filter convolutions directly, without FFT.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.FFTConvolution","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.FFTConvolution","text":"FFTConvolution() isa ConvolutionMethod\n\nCompute filter convolutions via FFT.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.FilteringType","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.FilteringType","text":"abstract type FilteringType\n\nIndended as a type parameter to designate the behavior of a filter as linear or nonlinear.\n\nSubtypes are LinearFiltering and NonlinearFiltering.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.FirstOrderIIR","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.FirstOrderIIR","text":"struct FirstOrderIIR{T<:RealQuantity} <: AbstractRadIIRFilter\n\nA biquad filter.\n\nConstructors:\n\nFirstOrderIIR(fields...)\n\nFields:\n\nb_01::Tuple{T, T} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real): Coefficients b0 to b1\na_1::Tuple{T} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real): Coefficient a1, a0 equals one implicitly\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.Gauss1DFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.Gauss1DFilter","text":"struct Gauss1DFilter <: AbstractRadFIRFilter\n\nOne dimensional gaussian filter defined as: f(x) = beta * exp(-0.5*(x/sigma)^2) / length\n\nwhere x is in the interval [-alphasigma, alphasigma]\n\nConstructors:\n\nGauss1DFilter(; fields...)\n\nFields:\n\nsigma::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: standard deviation Default: 1.0\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: total length of the filter Default: 100.0\nalpha::AbstractFloat: the amount of standard deviations to cover in the gaussian window Default: 1.0\nbeta::AbstractFloat: scaling factor Default: 100.0\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.IntegratorCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.IntegratorCRFilter","text":"struct IntegratorCRFilter <: AbstractRadIIRFilter\n\nA modified CR-filter. The filter has an inverse.\n\nConstructors:\n\nIntegratorCRFilter(fields...)\n\nFields:\n\ngain::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Filter gain\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.IntegratorFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.IntegratorFilter","text":"struct IntegratorFilter <: AbstractRadIIRFilter\n\nAn integrator filter. It's inverse is DifferentiatorFilter.\n\nConstructors:\n\nIntegratorFilter(fields...)\n\nFields:\n\ngain::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Filter gain\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.IntegratorModCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.IntegratorModCRFilter","text":"struct IntegratorModCRFilter <: AbstractRadIIRFilter\n\nA modified CR-filter. The filter has an inverse.\n\nConstructors:\n\nIntegratorModCRFilter(fields...)\n\nFields:\n\ngain::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Filter gain\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.Intersect","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.Intersect","text":"struct Intersect <: Function\n\nFinds the intersects of a Y with a threshold\n\nConstructors:\n\nIntersect(; fields...)\n\nFields:\n\nmintot::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: minimum time-over-threshold\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.InvCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.InvCRFilter","text":"struct InvCRFilter <: AbstractRadIIRFilter\n\nInverse of CRFilter.\n\nConstructors:\n\nInvCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.InvModCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.InvModCRFilter","text":"struct InvModCRFilter <: AbstractRadIIRFilter\n\nInverse of ModCRFilter.\n\nConstructors:\n\nInvModCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.InvRCFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.InvRCFilter","text":"struct InvRCFilter <: AbstractRadIIRFilter\n\nInverse of RCFilter.\n\nConstructors:\n\nInvRCFilter(fields...)\n\nFields:\n\nrc::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: RC time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.InvSecondOrderCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.InvSecondOrderCRFilter","text":"struct InvSecondOrderCRFilter <: AbstractRadIIRFilter\n\nInverse of SecondOrderCRFilter. Apply a double pole-zero cancellation using the provided time constants to the waveform.\n\nConstructors:\n\nInvSecondOrderCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: time constant of the first exponential to be deconvolved\ncr2::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: time constant of the second exponential to be deconvolved\nf::Real: the fraction faktor which the second exponential contributes\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.LinearFiltering","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.LinearFiltering","text":"abstract type LinearFiltering <: FilteringType\n\nWhen used as a type parameter value, marks linear behavior of a filter.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.ModCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.ModCRFilter","text":"struct ModCRFilter <: AbstractRadIIRFilter\n\nA first-order CR highpass filter, modified for full-amplitude step-signal response.\n\nThe resonse of the standard digital CRFilter will not recover the full amplitude of a digital step stignal since a step from one sample to the still has a finite rise time. This version of a CR filter compensates for this loss in amplitude, so it effectively treats a step as having\n\nThe inverse filter is InvModCRFilter, this is typically stable even in the presence of additional noise (see CRFilter).\n\nConstructors:\n\nModCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: CR time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.NonlinearFiltering","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.NonlinearFiltering","text":"abstract type NonlinearFiltering <: FilteringType\n\nWhen used as a type parameter value, marks non linear behavior of a filter.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.PolynomialDNI","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.PolynomialDNI","text":"struct PolynomialDNI <: DNIMethod\n\nPolynomial denoising and interpolation method.\n\nOperates in a similar way as a Savitzky-Golay filter, but interpolates as well.\n\nConstructors:\n\nPolynomialDNI(; fields...)\n\nFields:\n\ndegree::Int64: polynomial degree Default: (2, \"length\")\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.RCFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.RCFilter","text":"struct RCFilter <: AbstractRadII>RFilter\n\nA first-order RC lowpass filter.\n\nThe inverse filter is InvCRFilter, but note that this is unstable in the presence of additional noise. As an RC filter attenuates high-frequency noise, its inverse amplifies such noise and will typically not be useful to deconvolve signals in practical applications.\n\nConstructors:\n\nRCFilter(fields...)\n\nFields:\n\nrc::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: RC time constant\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SamplingInfo","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SamplingInfo","text":"struct SamplingInfo{T<:RealQuantity,A<:AbstractVector{<:RealQuantity}}\n\nHolds sampling information.\n\nThe numerical type of an individual sample is T, the (time) axis is given by the axis field.\n\nConstructors:\n\nSamplingInfo{T,A}(axis)\nSamplingInfo{T}(axis)\n\nFields:\n\naxis::AbstractVector{<:Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real}\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SavitzkyGolayFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SavitzkyGolayFilter","text":"struct SavitzkyGolayFilter <: AbstractRadFIRFilter\n\nA Savitzky-Golay filter.\n\nConstructors:\n\nSavitzkyGolayFilter(; fields...)\n\nFields:\n\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: filter length\ndegree::Int64: Polynomial defgree\nderivative::Int64: n-th derivative (0 for no derivative)\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SecondOrderCRFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SecondOrderCRFilter","text":"struct SecondOrderCRFilter <: AbstractRadIIRFilter\n\nA scond order CR highpass filter. The filter has an inverse InvSecondOrderCRFilter.\n\nConstructors:\n\nSecondOrderCRFilter(fields...)\n\nFields:\n\ncr::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: time constant of the first exponential to be deconvolved\ncr2::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: time constant of the second exponential to be deconvolved\nf::Real: the fraction faktor which the second exponential contributes\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SignalEstimator","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SignalEstimator","text":"struct SignalEstimator <: Function\n\nEstimates a signal at a given position x.\n\nUsage:\n\n(f::SamplesOrWaveform)(input::RDWaveform, x::RealQuantity)\n\nConstructors:\n\nSignalEstimator(; fields...)\n\nFields:\n\ndni::DNIMethod: denoising and interpolation method\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SimpleCSAFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SimpleCSAFilter","text":"struct SimpleCSAFilter <: AbstractRadIIRFilter\n\nSimulates the current-signal response of a charge-sensitive preamplifier with resistive reset, the output is a charge signal.\n\nIt is equivalent to the composition\n\nCRFilter(cr = tau_decay) ∘\nIntegrator(gain = gain) ∘\nRCFilter(rc = tau_rise)\n\nand maps to a single BiquadFilter.\n\nThis filter has an inverse, but the inverse is very unstable in the presence of additional noise if tau_rise is not zero (since the inverse of an RC-filter is unstable under noise). Even if tau_rise is zero the inverse will still amplify noise (since it differentiates), so it should be used very carefully when deconvolving signals in practical applications.\n\nConstructors:\n\nSimpleCSAFilter(fields...)\n\nFields:\n\ntau_rise::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Rise time constant\ntau_decay::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Decay time constant\ngain::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: Gain\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.TrapezoidalChargeFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.TrapezoidalChargeFilter","text":"struct TrapezoidalChargeFilter <: AbstractRadNonlinearFilter\n\nFilter that responds to a step signal with a trapezoidal pulse.\n\nThe filter is equivalent to two moving averages separated by a gap.\n\nConstructors:\n\nTrapezoidalChargeFilter(; fields...)\n\nFields:\n\navgtime::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: pre-rise averaging time\ngaptime::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: gap time\navgtime2::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: post-rise averaging time\n\nA sharp step on the input will result in a trapezoid with rise time and fall time avgtime and a flat top of length gaptime.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.TruncateFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.TruncateFilter","text":"struct TruncateFilter <: AbstractRadSigFilter{LinearFiltering}\n\nFilter that truncates the input signal.\n\nConstructors:\n\nTruncateFilter(; fields...)\n\nFields:\n\ninterval::IntervalSets.ClosedInterval{<:Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real}: interval to keep\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.ZACChargeFilter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.ZACChargeFilter","text":"struct ZACChargeFilter <: AbstractRadFIRFilter\n\nZero area cusp (ZAC) filter.\n\nFor the definition the filter and a discussion of the filter properties, see \"Improvement of the energy resolution via an optimized digital signal processing in GERDA Phase I\", Eur. Phys. J. C 75, 255 (2015).\n\nConstructors:\n\nZACChargeFilter(; fields...)\n\nFields:\n\nsigma::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: equivalent of shaping time (τₛ) Default: 450\ntoplen::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: length of flat top (FT) Default: 10\ntau::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: decay constant of the exponential Default: 20\nlength::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: total length of the filter (L) Default: 100\nbeta::AbstractFloat: scaling factor Default: 100.0\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.MaybeWithUnits","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.MaybeWithUnits","text":"const MaybeWithUnits{T<:Number} = Union{T,Quantity{<:T}}\n\nA numerical value with or without units\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.RealQuantity","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.RealQuantity","text":"const RealQuantity = MaybeWithUnits{<:Real}\n\nA real value with or without units.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.SamplesOrWaveform","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.SamplesOrWaveform","text":"const RadiationDetectorDSP.SamplesOrWaveform{T<:RealQuantity} = Union{AbstractSamples{T},RDWaveform{<:Any,T}}\n\nA vector of signal samples or a waveform.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.adapt_memlayout","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.adapt_memlayout","text":"RadiationDetectorDSP::adapt_memlayout(\n    fi::AbstractRadSigFilterInstance,\n    backend::KernelAbstractions.Backend,\n    A::AbstractArray{<:Number}\n)\n\nAdapts the memory layout of A in a suitable fashion for fi on computing device backend.\n\nReturns a row-major version of A on all backends by default, filter instance types may specialize this behavior.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.add_rect_pulse!","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.add_rect_pulse!","text":"add_rect_pulse!(samples::AbstractSamples, start::Integer, pulselen::Integer, amplitude::Real = 1.0)\n\nAdd a rectangular pulse to samples.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.bc_rdfilt","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.bc_rdfilt","text":"bc_rdfilt(flt::AbstractRadSigFilter, input)\nbc_rdfilt(fi::AbstractRadSigFilterInstance, input)\n\nBroadcast filter instance fi over signals input, return the filtered signals.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.bc_rdfilt!","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.bc_rdfilt!","text":"bc_rdfilt!(outputs, fi::AbstractRadSigFilterInstance, inputs)\n\nBroadcast filter flt or filter instance fi over signals inputs, storing the results in outputs.\n\ninputs and outputs must be of type AbstractVector{<:AbstractSamples}.\n\nReturns outputs.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.charge_trapflt!-Tuple{AbstractVector{<:Union{var\"#s10\", var\"#s32\"} where {var\"#s10\"<:AbstractFloat, var\"#s32\"<:(SIMD.Vec{N, <:var\"#s10\"} where N)}}, Integer, Integer}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.charge_trapflt!","text":"charge_trapflt!(samples::AbstractVector{<:RealOrSIMD{<:AbstractFloat}}, navg::Integer, ngap::Integer)\n\nApply a trapezoidal FIR filter to a charge signal in samples.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.cr_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.cr_filter","text":"cr_filter(CR::Real)\n\nReturn a DSP.jl-compatible CR-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.crmod_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.crmod_filter","text":"crmod_filter(CR::Real)\n\nReturn a DSP.jl-compatible modified CR-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.cusp_charge_filter_coeffs-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{Int64, U, Int64, V, W}} where {U, V, W<:AbstractFloat}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.cusp_charge_filter_coeffs","text":"cusp_charge_filter_coeffs(N::Int, sigma::U, FT::Int, tau::V, beta::W\n) where {U, V, W <: AbstractFloat}\n\nreturn a vector representing the cusp filter applicaible on a charge  signal, where N is the total length of the filter, FT the length of  the flat top, sigma the filter shaping time,tau the decay constant  and a the scaling factor.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.dfilt!","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.dfilt!","text":"rdfilt!(output, fi::AbstractRadSigFilterInstance, input)\n\nApply filter flt or filter instance fi to signal input and store the filtered signal in output. Return output.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.differentiator_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.differentiator_filter","text":"differentiator_filter(gain::Real)\n\nReturn a DSP.jl-compatible differentiator filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.elsmplinfo","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.elsmplinfo","text":"smplinfo(smpls::AbstractSamples)::SamplingInfo\nsmplinfo(wf::RDWaveform{T,U})::RDWaveform\n\nGet sampling information an array of vectors of samples, resp. an array of waveform. All elements must have equal samling information.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.flt_input_length","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.flt_input_length","text":"RadiationDetectorDSP.flt_input_length(fi::AbstractRadSigFilterInstance)::Integer\n\nGet the output signal length of a filter instance fi.\n\nMust be implemented for all subtypes of AbstractRadSigFilterInstance.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.flt_input_smpltype","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.flt_input_smpltype","text":"RadiationDetectorDSP.flt_input_smpltype(fi::AbstractRadSigFilterInstance)\n\nGet the input sample type of a filter instance fi.\n\nMust be implemented for all subtypes of AbstractRadSigFilterInstance.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.flt_output_length","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.flt_output_length","text":"RadiationDetectorDSP.flt_output_length(fi::SomeFilterInstance)::Integer\n\nGet the output signal length of filter instance fi.\n\nMust be implemented for all subtypes of AbstractRadSigFilterInstance.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.flt_output_smpltype","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.flt_output_smpltype","text":"RadiationDetectorDSP.flt_output_smpltype(fi::AbstractRadSigFilterInstance)\n\nGet the output sample type for\n\na filter flt given an input sample type input_smpltype\na filter instance fi\n\nMust be implemented for all subtypes of AbstractRadSigFilter.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.flt_output_time_axis","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.flt_output_time_axis","text":"RadiationDetectorDSP.flt_output_time_axis(fi::SomeFilterInstance, time::AbstractVector{<:RealQuantity})::AbstractVector{<:RealQuantity}\n\nGet the output time axis of a filter instance fi, given an input time axis time.\n\nMust be implemented for subtypes of AbstractRadSigFilter and AbstractRadSigFilterInstance only if the filter's output time axis can be computed directly from the input time axis.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.fltinstance","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.fltinstance","text":"fltinstance(flt::AbstractRadSigFilter, si::SamplingInfo)::AbstractRadSigFilterInstance\n\nCreate a filter instance of the filter flt, specialized for the given input, resp. input characteristics.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.gaussian_coeffs-Union{Tuple{U}, Tuple{V}, Tuple{Int64, V, U, U}} where {V, U<:AbstractFloat}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.gaussian_coeffs","text":"gaussian_coeffs(N::Int, sigma::V, alpha::U, beta::U) where {V, U}\n\ncompute a gaussian kernel, where N is the total length of the kernel,  alpha the amount of standard deviations to cover, sigma the standard  deviation and beta the total scaling factor.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.gen_rect_pulse","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.gen_rect_pulse","text":"gen_rect_pulse(tracelen::Integer, start::Integer, pulselen::Integer, amplitude::Real = 1.0)\n\nGenerate a rectangular pulse.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.integrator_cr_filter-Tuple{Real, Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.integrator_cr_filter","text":"integrator_cr_filter(gain::Real, CR::Real)\n\nReturn a DSP.jl-compatible integrator plus CR filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.integrator_crmod_filter-Tuple{Real, Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.integrator_crmod_filter","text":"integrator_crmod_filter(gain::Real, CR::Real)\n\nReturn a DSP.jl-compatible integrator plus modified CR filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.integrator_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.integrator_filter","text":"integrator_filter(gain::Real)\n\nReturn a DSP.jl-compatible integrator filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.inv_cr_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.inv_cr_filter","text":"inv_cr_filter(CR::Real)\n\nReturn a DSP.jl-compatible inverse CR-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.inv_crmod_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.inv_crmod_filter","text":"inv_crmod_filter(CR::Real)\n\nReturn a DSP.jl-compatible inverse modified CR-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.inv_rc_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.inv_rc_filter","text":"inv_rc_filter(RC::Real)\n\nReturn a DSP.jl-compatible RC-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.multiply_waveform","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.multiply_waveform","text":"multiply_waveform(signal::AbstractSamples, a::RealQuantity)\nmultiply_waveform(wf::RDWaveform, a::RealQuantity)\n\nMultiplies each sample of a waveform by a.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.rc_filter-Tuple{Real}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.rc_filter","text":"rc_filter(RC::Real)\n\nReturn a DSP.jl-compatible RC-filter.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.rdfilt","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.rdfilt","text":"rdfilt(fi::AbstractRadSigFilterInstance, input)\n\nApply filter instance fi to signal input, return the filtered signal.\n\nReturns output.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.reverse_waveform","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.reverse_waveform","text":"reverse_waveform(signal::AbstractSamples)\nreverse_waveform(wf::RDWaveform)\n\nReverses the order of samples in a waveform.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.shift_waveform","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.shift_waveform","text":"shift_waveform(signal::AbstractSamples, a::RealQuantity)\nshift_waveform(wf::RDWaveform, a::RealQuantity)\n\nShifts each sample of a waveform up by a.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.simple_csa_response_filter","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.simple_csa_response_filter","text":"simplecsaresponsefilter(τrise::Real, τdecay::Real, gain::Real = one(τrise))\n\nReturn a DSP.jl-compatible filter that models the response of a typical charge-sensitive amplifier (CSA).\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.smplinfo","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.smplinfo","text":"smplinfo(smpls::AbstractSamples)::SamplingInfo\nsmplinfo(wf::RDWaveform{T,U})::RDWaveform\n\nGet sampling information from a vector of samples, resp. a waveform.\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationDetectorDSP/#RadiationDetectorDSP.zac_charge_filter_coeffs-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{Int64, U, Int64, V, W}} where {U, V, W<:AbstractFloat}","page":"RadiationDetectorDSP","title":"RadiationDetectorDSP.zac_charge_filter_coeffs","text":"zac_charge_filter_coeffs(\n    N::Int, sigma::V, FT::Int, tau::T, beta::U\n    ) where {V, T, U <: AbstractFloat}\n\nreturn a vector representing the zac filter applicaible on a charge  signal, where N is the total length of the filter, FT the length of  the flat top, sigma the filter shaping time, tau the decay constant and beta an additional scaling factor. (see Eur. Phys. J. C (2015) 75:255).\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"","category":"section"},{"location":"packages/LegendEventAnalysis/","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"Also see LegendEventAnalysis on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendEventAnalysis/#Modules","page":"LegendEventAnalysis","title":"Modules","text":"","category":"section"},{"location":"packages/LegendEventAnalysis/","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"Modules = [LegendEventAnalysis]\nOrder = [:module]","category":"page"},{"location":"packages/LegendEventAnalysis/#Types-and-constants","page":"LegendEventAnalysis","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendEventAnalysis/","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"Modules = [LegendEventAnalysis]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendEventAnalysis/#Functions-and-macros","page":"LegendEventAnalysis","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendEventAnalysis/","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"Modules = [LegendEventAnalysis]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendEventAnalysis/#Documentation","page":"LegendEventAnalysis","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendEventAnalysis/","page":"LegendEventAnalysis","title":"LegendEventAnalysis","text":"Modules = [LegendEventAnalysis]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.apply_event_map-Tuple{StructArrays.StructVector, StructArrays.StructVector}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.apply_event_map","text":"apply_event_map(data::StructVector, evtmap::StructVector)\n\nApply the event map evtmap to the data data.\n\ndata will typically be the result of flatten_over_channels and evtmap the result of build_global_event_map.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.build_cross_system_events-Tuple{NamedTuple}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.build_cross_system_events","text":"function build_cross_system_events(\n    data::NamedTuple,\n    ts_window::Number = 25u\"μs\"\n)\n\nBuild cross-system events.\n\ndata must be a NamedTuple with properties that represent the names of experiment (sub)-systems and values that are the result of build_global_events for each system.\n\nNote: Currently requires the tstart columns of all systems to be identical.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.build_global_event_map-Tuple{StructArrays.StructVector}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.build_global_event_map","text":"build_global_event_map(local_events::StructArray; ts_window::Number = 25u\"μs\")\n\nBuild a map of global events based on local_events.\n\ndata must contain columns channel, chevtno and timestamp. It will typically be the result of flatten_over_channels.\n\nReturns a StructArray that contains the columns start, channels, localevents and timestamps, sorted by start globally and along timestamps in each row.\n\nThe start column contains the start time of each event, the channels, chevts and timestamps columns are vectors of vectors that contain the channel-id, per-channel event numbers and per-channel timestamps that have been associated with each respective events.\n\nPer-channel events are accociated with the same global event if their timestamps fall within a time windows of length ts_window.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.build_global_events","page":"LegendEventAnalysis","title":"LegendEventAnalysis.build_global_events","text":"function build_global_events(\n    data::AbstractDict{<:ChannelIdLike},\n    channels::AbstractVector{<:ChannelIdLike} = collect(keys(data));\n    ts_window::Number = 25u\"μs\"\n)\n\nBuild global events from a dictionary of per-channel events\n\nPer-channel events are accociated with the same global event if their timestamps fall within a time windows of length ts_window.\n\ndata must a dictionary of in-memory or on-disk table-like objects, keyed by channel-IDs. It may, e.g. be a Dict with values that are StructArrays.StructVector, TypedTables.Table or similar, but may also be a LegendHDF5IO.LHDataStore. Note that on-disk data will be read into memory as a whole.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.calibrate_all-Tuple{LegendData, ValiditySelection, AbstractDict}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.calibrate_all","text":"calibrate_all(data::LegendData, sel::ValiditySelection, datastore::AbstractDict)\n\nCalibrate all channels in the given datastore, using the metadata processing configuration for data and sel.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.calibrate_ged_channel_data-Tuple{LegendData, ValiditySelection, DetectorId, AbstractVector}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.calibrate_ged_channel_data","text":"calibrate_ged_channel_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, channel_data::AbstractVector)\n\nApply the calibration specified by data and sel for the given HPGe detector to the single-channel channel_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.calibrate_pls_channel_data-Tuple{LegendData, ValiditySelection, DetectorId, AbstractVector}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.calibrate_pls_channel_data","text":"calibrate_pls_channel_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, channel_data::AbstractVector)\n\nApply the calibration specified by data and sel for pulser referred to by the detector ID to the single-channel channel_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.calibrate_spm_channel_data-Tuple{LegendData, ValiditySelection, DetectorId, AbstractVector}","page":"LegendEventAnalysis","title":"LegendEventAnalysis.calibrate_spm_channel_data","text":"calibrate_spm_channel_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, channel_data::AbstractVector)\n\nApply the calibration specified by data and sel for the given SiPM detector to the single-channel channel_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendEventAnalysis/#LegendEventAnalysis.flatten_over_channels","page":"LegendEventAnalysis","title":"LegendEventAnalysis.flatten_over_channels","text":"function flatten_over_channels(\n    data::AbstractDict{<:ChannelIdLike},\n    channels::AbstractVector{<:ChannelIdLike} = collect(keys(data))\n)\n\nFlatten per-channel data data to a single StructArrays.StructVector by concatenating its table-like values and adding the columns a channel and chevtno.\n\ndata must a dictionary of in-memory or on-disk table-like objects, keyed by channel-IDs. It may, e.g. be a Dict with values that are StructArrays.StructVector, TypedTables.Table or similar, but may also be a LegendHDF5IO.LHDataStore. Note that on-disk data will be read into memory as a whole.\n\nReturns a NamedTuple{(:result, :per_channel)}: result is the flattened data and per_channel is a channel-indexed dictionary of views into result.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendSpecFits/#LegendSpecFits","page":"LegendSpecFits","title":"LegendSpecFits","text":"","category":"section"},{"location":"packages/LegendSpecFits/","page":"LegendSpecFits","title":"LegendSpecFits","text":"Also see LegendSpecFits on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendSpecFits/#Modules","page":"LegendSpecFits","title":"Modules","text":"","category":"section"},{"location":"packages/LegendSpecFits/","page":"LegendSpecFits","title":"LegendSpecFits","text":"Modules = [LegendSpecFits]\nOrder = [:module]","category":"page"},{"location":"packages/LegendSpecFits/#Types-and-constants","page":"LegendSpecFits","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendSpecFits/","page":"LegendSpecFits","title":"LegendSpecFits","text":"Modules = [LegendSpecFits]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendSpecFits/#Functions-and-macros","page":"LegendSpecFits","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendSpecFits/","page":"LegendSpecFits","title":"LegendSpecFits","text":"Modules = [LegendSpecFits]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendSpecFits/#Documentation","page":"LegendSpecFits","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendSpecFits/","page":"LegendSpecFits","title":"LegendSpecFits","text":"Modules = [LegendSpecFits]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendSpecFits/#LegendSpecFits.LegendSpecFits","page":"LegendSpecFits","title":"LegendSpecFits.LegendSpecFits","text":"LegendSpecFits\n\nTemplate for Julia packages.\n\n\n\n\n\n","category":"module"},{"location":"packages/LegendSpecFits/#LegendSpecFits.aoe_compton_background_peakshape-NTuple{5, Real}","page":"LegendSpecFits","title":"LegendSpecFits.aoe_compton_background_peakshape","text":"aoe_compton_background_peakshape(\n    x::Real, μ::Real, σ::Real,\n    background::Real, δ::Real\n)\n\nDescribes the background shape of a typical A/E Compton peak in a detector as a step like background for MSE events.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.aoe_compton_peakshape-NTuple{6, Real}","page":"LegendSpecFits","title":"LegendSpecFits.aoe_compton_peakshape","text":"aoe_compton_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real,\n    background::Real, δ::Real\n)\n\nDescribes the shape of a typical A/E Compton peak in a detector as a gaussian SSE peak and a step like background for MSE events.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.aoe_compton_signal_peakshape-NTuple{4, Real}","page":"LegendSpecFits","title":"LegendSpecFits.aoe_compton_signal_peakshape","text":"aoe_compton_signal_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real\n)\n\nDescribes the signal shape of a typical A/E Compton peak in a detector as a gaussian SSE peak.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.array_to_tuple-Tuple{AbstractArray, NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.array_to_tuple","text":"array_to_tuple(a::AbstractArray, as_nt::NamedTuple)\n\nReturn a NamedTuple with the values of a in the order given by fieldnames(as_nt).\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.autocal_energy-Tuple{AbstractArray{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.autocal_energy","text":"autocal_energy(E_raw::AbstractArray{<:Real})\n\nCompute an energy calibration from raw reconstructed energy deposition values.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.background_peakshape-NTuple{5, Real}","page":"LegendSpecFits","title":"LegendSpecFits.background_peakshape","text":"background_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real,\n    skew_fraction::Real, skew_width::Real,\n)\n\nDescribes the background part of the shape of a typical gamma peak in a detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.calibrate_energy!-Union{Tuple{T}, Tuple{Array{T}, PropDicts.PropDict}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.calibrate_energy!","text":"calibrate_energy!(e::AbstractArray{<:Real}, pars::PropDict)\n\nCalibrate energy values in-place.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.correct_aoe!-Union{Tuple{T}, Tuple{Array{T}, Array{T}, NamedTuple{(:e, :μ, :f_μ_scs, :μ_scs_slope, :μ_scs_intercept, :σ, :σ_scs, :f_σ_scs)}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.correct_aoe!","text":"correctAoE!(aoe::Array{T}, e::Array{T}, aoe_corrections::NamedTuple{(:e, :μ, :f_μ_scs, :μ_scs_slope, :μ_scs_intercept, :σ, :σ_scs, :f_σ_scs)}) where T<:Real\n\nCorrect the AoE values in the aoe array using the corrections in aoe_corrections.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.ctc_energy-Union{Tuple{T}, Tuple{Array{T}, Array{T}, T, T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.ctc_energy","text":"ctc_energy(e::Array{T}, qdrift::Array{T}, peak::T, window::T) where T<:Real\n\nCorrect for the drift time dependence of the energy by minimizing the ratio of the FWHM and the peak height of the peak around peak in e with a cut window of window. The drift time dependence is given by qdrift.\n\nReturns\n\n* `peak`: peak position\n* `window`: window size\n* `fct`: correction factor\n* `bin_width`: optimal bin width\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.cut_single_peak-Union{Tuple{T}, Tuple{Vector{T}, T, T}, Tuple{Vector{T}, T, T, Int64}, Tuple{Vector{T}, T, T, Int64, Float64}} where T<:Union{Real, Unitful.AbstractQuantity{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.cut_single_peak","text":"cut_single_peak(x::Array, min_x::Float64, max_x::Float64, n_bins::Int=15000, relative_cut::Float64=0.5)\n\nCut out a single peak from the array x between min_x and max_x. The number of bins is the number of bins to use for the histogram. The relative cut is the fraction of the maximum counts to use for the cut.\n\nReturns\n\n* `max`: maximum position of the peak\n* `low`: lower edge of the cut peak\n* `high`: upper edge of the cut peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.estimate_combined_peak_stats-Tuple{StructArrays.StructArray}","page":"LegendSpecFits","title":"LegendSpecFits.estimate_combined_peak_stats","text":"estimate_combined_peak_stats(peakstats::StructArray,; calib_type::Symbol=:th228)\n\nEstimate the peak position, FWHM, sigma, counts and background of a peak from a histogram.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.estimate_fwhm-Tuple{NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.estimate_fwhm","text":"estimate_fwhm(v::NamedTuple, v_err::NamedTuple)\n\nGet the FWHM of a peak from the fit parameters.\n\nReturns\n\n* `fwhm`: the FWHM of the peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.estimate_single_peak_stats-Tuple{StatsBase.Histogram}","page":"LegendSpecFits","title":"LegendSpecFits.estimate_single_peak_stats","text":"estimate_single_peak_stats(h::Histogram, calib_type::Symbol=:th228)\n\nEstimate statistics/parameters for a single peak in the given histogram h.\n\nh must only contain a single peak. The peak should have a Gaussian-like shape. calib_type specifies the calibration type. Currently only :th228 is implemented. If you want get the peak statistics for a PSD calibration, use :psd.\n\nReturns\n\nNamedTuple with the fields     * peak_pos: estimated position of the peak (in the middle of the peak)     * peak_fwhm: full width at half maximum (FWHM) of the peak     * peak_sigma: estimated standard deviation of the peak     * peak_counts: estimated number of counts in the peak     * mean_background: estimated mean background value\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.estimate_single_peak_stats_psd-Union{Tuple{StatsBase.Histogram{T}}, Tuple{T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.estimate_single_peak_stats_psd","text":"estimate_single_peak_stats_psd(h::Histogram{T}) where T<:Real\n\nEstimate peak parameters for a single peak in a histogram using the maximum, the FWHM and the area of the peak.\n\nReturns\n\n* `peak_pos`: Position of the peak\n* `peak_fwhm`: Full width at half maximum of the peak\n* `peak_sigma`: Standard deviation of the peak\n* `peak_counts`: Counts of the peak\n* `mean_background`: Mean background of the peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.ex_gauss_pdf-NTuple{4, Real}","page":"LegendSpecFits","title":"LegendSpecFits.ex_gauss_pdf","text":"ex_gauss_pdf(x::Real, μ::Real, σ::Real, θ::Real)\n\nThe PDF of an Exponentially modified Gaussian distribution with Gaussian parameters μ, σ and exponential scale θ at x.\n\nIt is the PDF of the distribution that descibes the random process rand(Normal(μ, σ)) + rand(Exponential(θ)).\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.ex_step_gauss-NTuple{5, Real}","page":"LegendSpecFits","title":"LegendSpecFits.ex_step_gauss","text":"ex_step_gauss(x::Real, l::Real, k::Real, t::Real, d::Real)\n\nEvaluates an extended step gauss model at x with parameters l, k, t and d.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.expand_vars-Tuple{NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.expand_vars","text":"expand_vars(v::NamedTuple)::StructArray\n\nExpand all fields in v (scalars or arrays) to same array size and return a StructArray.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.exponential_decay-NTuple{4, Real}","page":"LegendSpecFits","title":"LegendSpecFits.exponential_decay","text":"exponential_decay(x::Real, amplitude::Real, decay::Real, offset::Real)\n\nEvaluates an exponential decay function at x with parameters amplitude, decay and offset.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.f_optimize_ctc-NTuple{4, Any}","page":"LegendSpecFits","title":"LegendSpecFits.f_optimize_ctc","text":"f_optimize_ctc(fct, e, qdrift, bin_width)\n\nCalculate the ratio of the FWHM and the peak height of the peak around peak in e with a cut window of window. The drift time dependence is given by e_ctc = e + fct * qdrift.\n\nReturns\n\n* `fwhm / p_height`: FWHM of the peak divided by peak height\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_aoe_compton-Union{Tuple{T}, Tuple{Array, StructArrays.StructArray, Array{T}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.fit_aoe_compton","text":"fit_aoe_compton(peakhists::Array, peakstats::StructArray, compton_bands::Array{T}) where T<:Real\n\nFit the A/E Compton bands using the f_aoe_compton function consisting of a gaussian SSE peak and a step like background for MSE events.\n\nReturns\n\n* `result`: Dict of NamedTuples of the fit results containing values and errors for each compton band\n* `report`: Dict of NamedTuples of the fit report which can be plotted for each compton band\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_aoe_corrections-Union{Tuple{T}, Tuple{Array{<:Real}, Array{T}, Array{T}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.fit_aoe_corrections","text":"fit_aoe_corrections(e::Array{<:Real}, μ::Array{T}, σ::Array{T}) where T<:Real\n\nFit the corrections for the AoE value of the detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_calibration-Tuple{Array, Array}","page":"LegendSpecFits","title":"LegendSpecFits.fit_calibration","text":"fitCalibration\n\nFit the calibration lines to a linear function.\n\nReturns\n\n* `slope`: the slope of the linear fit\n* `intercept`: the intercept of the linear fit\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_enc_sigmas-Union{Tuple{T}, Tuple{Matrix{T}, StepRangeLen{Unitful.Quantity{<:T}, Base.TwicePrecision{Unitful.Quantity{<:T}}, Base.TwicePrecision{Unitful.Quantity{<:T}}, Int64}, T, T, Int64, T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.fit_enc_sigmas","text":"fit_enc_sigmas(enc_grid::Matrix{T}, enc_grid_rt::StepRangeLen{Quantity{<:T}, Base.TwicePrecision{Quantity{<:T}}, Base.TwicePrecision{Quantity{<:T}}, Int64}, min_enc::T, max_enc::T, nbins::Int64, rel_cut_fit::T) where T<:Real\n\nFit the ENC values in enc_grid for each RT in enc_grid_rt with a Gaussian and return the optimal RT and the corresponding ENC value.\n\nArguments\n\nenc_grid: 2D array of ENC values for each RT in enc_grid_rt\nenc_grid_rt: 1D array of RT values for which the ENC values in enc_grid are calculated\nmin_enc: minimum ENC value to consider for the fit\nmax_enc: maximum ENC value to consider for the fit\nnbins: number of bins to use for the histogram of ENC values\nrel_cut_fit: relative cut value to use for the fit\n\nReturns\n\nrt: optimal RT value\nmin_enc: corresponding ENC value\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_fwhm-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.fit_fwhm","text":"fitFWHM(fit_fwhm(peaks::Vector{T}, fwhm::Vector{T}) where T<:Real\n\nFit the FWHM of the peaks to a quadratic function.\n\nReturns\n\n* `qbb`: the FWHM at 2039 keV\n* `err`: the uncertainties of the fit parameters\n* `v`: the fit result parameters\n* `f_fit`: the fitted function\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_fwhm_ft_fep-Union{Tuple{T}, Tuple{Matrix, StepRangeLen{Unitful.Quantity{<:T}, Base.TwicePrecision{Unitful.Quantity{<:T}}, Base.TwicePrecision{Unitful.Quantity{<:T}}, Int64}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.fit_fwhm_ft_fep","text":"fit_fwhm_ft_fep(e_grid::Matrix{T}, e_grid_ft::StepRangeLen{Quantity{<:T}, Base.TwicePrecision{Quantity{<:T}}, Base.TwicePrecision{Quantity{<:T}}, Int64}) where T <:Real\n\nFit the FWHM values in e_grid for each FT in e_grid_ft with a Gamma Peakshape and return the optimal FT and the corresponding FWHM value.\n\nArguments\n\ne_grid: 2D array of energy values for each FT in e_grid_ft\ne_grid_ft: 1D array of FT values for which the FWHM values in e_grid are calculated\n\nReturns\n\nft: optimal FT value\nmin_fwhm: corresponding FWHM value\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_half_centered_trunc_gauss-Union{Tuple{T}, Tuple{Vector{T}, T, @NamedTuple{low::T, high::T, max::T}}} where T<:Union{Real, Unitful.AbstractQuantity{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.fit_half_centered_trunc_gauss","text":"fit_half_centered_trunc_gauss(x::Array, cuts::NamedTuple{(:low, :high, :max), Tuple{Float64, Float64, Float64}})\n\nFit a single truncated Gaussian to the data x between cut.low and cut.high. The peak center is fixed at μ and the peak is cut in half either in the left or right half.\n\nReturns report and result` with:\n\n* `f_fit`: fitted function\n* `μ`: mean of the Gaussian\n* `μ_err`: error of the mean\n* `σ`: standard deviation of the Gaussian\n* `σ_err`: error of the standard deviation\n* `n`: number of counts in the peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_peaks-Tuple{Array, StructArrays.StructArray, Array}","page":"LegendSpecFits","title":"LegendSpecFits.fit_peaks","text":"fitPeaks\n\nPerform a fit of the peakshape to the data in peakhists using the initial values in peakstats to the calibration lines in th228_lines.\n\nReturns\n\n* `peak_fit_plots`: array of plots of the peak fits\n* `return_vals`: dictionary of the fit results\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_peaks_combined-Tuple{Array, StructArrays.StructArray, Array}","page":"LegendSpecFits","title":"LegendSpecFits.fit_peaks_combined","text":"fit_peaks_combined(peakhists::Array, peakstats::StructArray, th228_lines::Array{T},; calib_type::Symbol=:th228, uncertainty::Bool=true, fixed_position::Bool=false) where T<:Real\n\nFit the peaks of a histogram to a combined peakshape function while sharring parameters between peaks.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_single_aoe_compton-Union{Tuple{T}, Tuple{StatsBase.Histogram, @NamedTuple{peak_pos::T, peak_fwhm::T, peak_sigma::T, peak_counts::T, mean_background::T}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.fit_single_aoe_compton","text":"fit_single_aoe_compton(h::Histogram, ps::NamedTuple{(:peak_pos, :peak_fwhm, :peak_sigma, :peak_counts, :mean_background, :μ, :σ), NTuple{7, T}}; uncertainty::Bool=true) where T<:Real\n\nPerform a fit of the peakshape to the data in h using the initial values in ps while using the f_aoe_compton function consisting of a gaussian SSE peak and a step like background for MSE events.\n\nReturns\n\n* `result`: NamedTuple of the fit results containing values and errors\n* `report`: NamedTuple of the fit report which can be plotted\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_single_peak_th228-Union{Tuple{T}, Tuple{StatsBase.Histogram, @NamedTuple{peak_pos::T, peak_fwhm::T, peak_sigma::T, peak_counts::T, mean_background::T}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.fit_single_peak_th228","text":"fit_single_peak_th228(h::Histogram, ps::NamedTuple{(:peak_pos, :peak_fwhm, :peak_sigma, :peak_counts, :mean_background), NTuple{5, T}};, uncertainty::Bool=true, fixed_position::Bool=false) where T<:Real\n\nPerform a fit of the peakshape to the data in h using the initial values in ps while using the gamma_peakshape with low-E tail. Also, FWHM is calculated from the fitted peakshape with MC error propagation.  The peak position can be fixed to the value in ps by setting fixed_position=true.\n\nReturns\n\n* `result`: NamedTuple of the fit results containing values and errors\n* `report`: NamedTuple of the fit report which can be plotted\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.fit_single_trunc_gauss-Union{Tuple{T}, Tuple{Vector{T}, @NamedTuple{low::T, high::T, max::T}}} where T<:Union{Real, Unitful.AbstractQuantity{<:Real}}","page":"LegendSpecFits","title":"LegendSpecFits.fit_single_trunc_gauss","text":"fit_single_trunc_gauss(x::Array, cuts::NamedTuple{(:low, :high, :max), Tuple{Float64, Float64, Float64}})\n\nFit a single truncated Gaussian to the data x between min_x and max_x. Returns report and resultwith:     *ffit: fitted function     *μ: mean of the Gaussian     *μerr: error of the mean     *σ: standard deviation of the Gaussian     *σ_err: error of the standard deviation     *n`: number of counts in the peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.gamma_peakshape-NTuple{8, Real}","page":"LegendSpecFits","title":"LegendSpecFits.gamma_peakshape","text":"gamma_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real,\n    step_amplitude::Real, skew_fraction::Real, skew_width::Real,\n    background::Real\n)\n\nDescribes the shape of a typical gamma peak in a detector with a flat background.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.gauss_pdf-Tuple{Real, Real, Real}","page":"LegendSpecFits","title":"LegendSpecFits.gauss_pdf","text":"LegendSpecFits.gauss_pdf(x::Real, μ::Real, σ::Real)\n\nEquivalent to pdf(Normal(μ, σ), x)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.generate_aoe_compton_bands-Union{Tuple{T}, Tuple{Array{<:Real}, Array{<:Real}, Array{<:Real}, T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.generate_aoe_compton_bands","text":"generate_aoe_compton_bands(aoe::Array{<:Real}, e::Array{<:Real}, compton_bands::Array{<:Real}, compton_window::T) where T<:Real\n\nGenerate histograms for the A/E Compton bands and estimate peak parameters.  The compton bands are cutted out of the A/E spectrum and then binned using the Freedman-Diaconis Rule. For better performance the binning is only done in the area around the peak. The peak parameters are estimated using the estimate_single_peak_stats_psd function.\n\nReturns\n\n* `peakhists`: Array of histograms for each compton band\n* `peakstats`: StructArray of peak parameters for each compton band\n* `min_aoe`: Array of minimum A/E values for each compton band\n* `max_aoe`: Array of maximum A/E values for each compton band\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_continuum_surrival_fraction-Union{Tuple{T}, Tuple{Array{T}, Array{T}, T, T, T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.get_continuum_surrival_fraction","text":"get_continuum_surrival_fraction(aoe::Array{T}, e::Array{T}, center::T, window::T, psd_cut::T,; uncertainty=true) where T<:Real\n\nGet the surrival fraction of a continuum after a PSD cut value psd_cut for a given center and window size.\n\nReturns\n\ncenter: Center of the continuum\nwindow: Window size\nn_before: Number of counts before the cut\nn_after: Number of counts after the cut\nsf: Surrival fraction\nerr: Uncertainties\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_dep_peakhists-Union{Tuple{T}, Tuple{Array{T}, Array{T}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.get_dep_peakhists","text":"get_aoe_peakhists(aoe::Array{T}, e::Array{T}) where T<:Real\n\nGet the histograms of the DEP in the AoE spectrum.\n\nReturns\n\nhist: Histogram of the DEP peak\nstats: Stats of the DEP peak\ndep: Position of the DEP peak\nwindow: Window size around the DEP peak\ne: Energy values in the window around the DEP peak\naoe: AoE values in the window around the DEP peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_distribution_transform","page":"LegendSpecFits","title":"LegendSpecFits.get_distribution_transform","text":"get_distribution_transform(d::Distribution, pprior::Prior)\n\nReturn a DistributionTransform for the given Distribution and Prior.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_mc_value_shapes-Tuple{NamedTuple, NamedTuple, Int64}","page":"LegendSpecFits","title":"LegendSpecFits.get_mc_value_shapes","text":"get_mc_value_shapes(v::NamedTuple, v_err::NamedTuple, n::Int64)\n\nReturn a NamedTuple with the same fields as v and v_err but with Normal distributions for each field.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_n_after_psd_cut-Union{Tuple{T}, Tuple{T, Array{T}, Array{T}, T, T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.get_n_after_psd_cut","text":"get_n_after_psd_cut(psd_cut::T, aoe::Array{T}, e::Array{T}, peak::T, window::T,; uncertainty=true) where T<:Real\n\nGet the number of counts after a cut value psd_cut for a given peak and window size whiile performing a peak fit with fixed position.\n\n# Returns\n\nn: Number of counts after the cut\nn_err: Uncertainty of the number of counts after the cut\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_peak_fwhm_th228","page":"LegendSpecFits","title":"LegendSpecFits.get_peak_fwhm_th228","text":"get_peak_fwhm_th228(v_ml::NamedTuple, v_ml_err::NamedTuple)\n\nGet the FWHM of a peak from the fit parameters while performing a MC error propagation.\n\nReturns\n\n* `fwhm`: the FWHM of the peak\n* `fwhm_err`: the uncertainty of the FWHM of the peak\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_peak_surrival_fraction-Union{Tuple{T}, Tuple{Array{T}, Array{T}, T, T, T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.get_peak_surrival_fraction","text":"get_peak_surrival_fraction(aoe::Array{T}, e::Array{T}, peak::T, window::T, psd_cut::T,; uncertainty=true) where T<:Real\n\nGet the surrival fraction of a peak after a PSD cut value psd_cut for a given peak and window size whiile performing a peak fit with fixed position.\n\nReturns\n\npeak: Peak position\nn_before: Number of counts before the cut\nn_after: Number of counts after the cut\nsf: Surrival fraction\nerr: Uncertainties\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_peaks_surrival_fractions-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Array{Symbol}, Array{T}, T}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.get_peaks_surrival_fractions","text":"get_peaks_surrival_fractions(aoe::Array{T}, e::Array{T}, peaks::Array{T}, peak_names::Array{Symbol}, windows::Array{T}, psd_cut::T,; uncertainty=true) where T<:Real\n\nGet the surrival fraction of a peak after a PSD cut value psd_cut for a given peak and window size while performing a peak fit with fixed position.\n\nReturn\n\nresult: Dict of results for each peak\nreport: Dict of reports for each peak\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.get_psd_cut-Union{Tuple{T}, Tuple{Array{T}, Array{T}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.get_psd_cut","text":"get_psd_cut(aoe::Array{T}, e::Array{T},; dep_sf::Float64=0.9) where T<:Real\n\nGet the PSD cut value for a given DEP surrival fraction dep_sf (Default: 90%). The cut value is determined by finding the cut value where the number of counts after the cut is dep_sf of the number of counts before the cut. The algorithm is based on a root search function and expecting a Bisection.\n\nReturns\n\ncut: PSD cut value\nn0: Number of counts before the cut\nn90: Number of counts after the cut\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.hist_loglike-Tuple{Union{Function, Type}, StatsBase.Histogram{<:Real, 1}}","page":"LegendSpecFits","title":"LegendSpecFits.hist_loglike","text":"hist_loglike(f_fit::Base.Callable, h::Histogram{<:Real,1})\n\nCalculate the Poisson log-likelihood of a fit function f_fit(x) and a histogram h. f_fit must accept all values x on the horizontal axis of the histogram.\n\nCurrently uses a simple midpoint-rule integration of f_fit over the bins of h.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.linear_function-Tuple{Real, Real, Real}","page":"LegendSpecFits","title":"LegendSpecFits.linear_function","text":"linear_function(x::Real, slope::Real, intercept::Real)\n\nEvaluates a linear function at x with parameters slope and intercept.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.lowEtail_peakshape-NTuple{6, Real}","page":"LegendSpecFits","title":"LegendSpecFits.lowEtail_peakshape","text":"lowEtail_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real,\n    skew_fraction::Real, skew_width::Real,\n)\n\nDescribes the low-E signal tail part of the shape of a typical gamma peak in a detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.signal_peakshape-NTuple{5, Real}","page":"LegendSpecFits","title":"LegendSpecFits.signal_peakshape","text":"signal_peakshape(\n    x::Real, μ::Real, σ::Real, n::Real,\n    skew_fraction::Real, skew_width::Real,\n)\n\nDescribes the signal part of the shape of a typical gamma peak in a detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.simple_calibration-Union{Tuple{T}, Tuple{AbstractArray{<:Real}, Array{T}, Array{T}}} where T<:Real","page":"LegendSpecFits","title":"LegendSpecFits.simple_calibration","text":"simple_calibration(e_uncal::Array, th228_lines::Array, window_size::Float64=25.0, n_bins::Int=15000, calib_type::String=\"th228\")\n\nPerform a simple calibration for the uncalibrated energy array e_uncal  using the calibration type calib_type and the calibration lines th228_lines.  The window size is the size of the window around the calibration line to use for the calibration.  The number of bins is the number of bins to use for the histogram.\n\nReturns      * h_calsimple: histogram of the calibrated energy array     * h_uncal: histogram of the uncalibrated energy array     * c: calibration factor     * fep_guess: estimated full energy peak (FEP)     * peakhists: array of histograms around the calibration lines     * peakstats: array of statistics for the calibration line fits\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.step_gauss-Tuple{Real, Real, Real}","page":"LegendSpecFits","title":"LegendSpecFits.step_gauss","text":"step_gauss(x::Real, μ::Real, σ::Real)\n\nEvaluates the convulution of a Heaviside step function and the PDF of Normal(μ, σ) at x.\n\nThe result does not correspond to a PDF as it is not normalizable.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.subhist-Tuple{StatsBase.Histogram{<:Any, 1}, Tuple{Real, Real}}","page":"LegendSpecFits","title":"LegendSpecFits.subhist","text":"subhist(h::Histogram, r::Tuple{<:Real,<:Real})\n\nReturn a new Histogram with the bins in the range r.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.tuple_to_array-Tuple{NamedTuple}","page":"LegendSpecFits","title":"LegendSpecFits.tuple_to_array","text":"tuple_to_array(nt::NamedTuple, fields::Vector{Symbol})\n\nReturn an array with the values of the fields in nt in the order given by fields.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendSpecFits/#LegendSpecFits.weibull_from_mx","page":"LegendSpecFits","title":"LegendSpecFits.weibull_from_mx","text":"weibull_from_mx(m::Real, x::Real, p_x::Real = 0.6827)::Weibull\n\nConstruct a Weibull distribution with a given median m and a given p_x-quantile x.\n\nUseful to construct priors for positive quantities.\n\n\n\n\n\n","category":"function"},{"location":"examples/detector_geometries/#Using-SolidStateDetectors-with-LegendDataManagment","page":"Detector Geometries","title":"Using SolidStateDetectors with LegendDataManagment","text":"","category":"section"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"LegendDataManagment is integrated with for SolidStateDetectors. This makes it possible to create SolidStateDetector instances from LEGEND metadata.","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"Example (requires a $LEGEND_DATA_CONFIG environment variable pointing to a LEGEND data-config file, replace V99000A with a valid detector name):","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"using Juleana, SolidStateDetectors, Plots\ndet = SolidStateDetector(LegendData(:l200), :V99000A)\nplot(det)","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"A detector can also be constructed using the filename of the LEGEND metadata detector-datasheet JSON file (no $LEGEND_DATA_CONFIG required):","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"det = SolidStateDetector(LegendData, \"V99000A.json\")","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"The following code will generate an overview plot of every 5th LEGEND detector (requires the actual LEGEND metadata instead of the metadata in legend-testdata):","category":"page"},{"location":"examples/detector_geometries/","page":"Detector Geometries","title":"Detector Geometries","text":"using Juleana, SolidStateDetectors, Plots\nl200 = LegendData(:l200)\ndetnames = propertynames(l200.metadata.hardware.detectors.germanium.diodes)\nplot(\n    plot.(SolidStateDetector.(Ref(l200), detnames[1:5:120]))...,\n    layout = (3,8), lw = 0.05, legend = false, grid = false, showaxis = false,\n    xlims = (-0.05,0.05), ylims = (-0.05,0.05), zlims = (0,0.1), size = (4000,1500)\n)","category":"page"},{"location":"packages/LegendDataTypes/#LegendDataTypes","page":"LegendDataTypes","title":"LegendDataTypes","text":"","category":"section"},{"location":"packages/LegendDataTypes/","page":"LegendDataTypes","title":"LegendDataTypes","text":"Also see LegendDataTypes on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendDataTypes/#Modules","page":"LegendDataTypes","title":"Modules","text":"","category":"section"},{"location":"packages/LegendDataTypes/","page":"LegendDataTypes","title":"LegendDataTypes","text":"Modules = [LegendDataTypes]\nOrder = [:module]","category":"page"},{"location":"packages/LegendDataTypes/#Types-and-constants","page":"LegendDataTypes","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendDataTypes/","page":"LegendDataTypes","title":"LegendDataTypes","text":"Modules = [LegendDataTypes]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendDataTypes/#Functions-and-macros","page":"LegendDataTypes","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendDataTypes/","page":"LegendDataTypes","title":"LegendDataTypes","text":"Modules = [LegendDataTypes]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendDataTypes/#Documentation","page":"LegendDataTypes","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendDataTypes/","page":"LegendDataTypes","title":"LegendDataTypes","text":"Modules = [LegendDataTypes]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendDataTypes/#LegendDataTypes.RadwareSigcompress","page":"LegendDataTypes","title":"LegendDataTypes.RadwareSigcompress","text":"RadwareSigcompress <: AbstractArrayCodec\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataTypes/#LegendDataTypes.TableLike","page":"LegendDataTypes","title":"LegendDataTypes.TableLike","text":"TableLike = AbstractVector{<:NamedTuple}\n\nThe type must also support the Tables.jl interface.\n\nExamples are TypedTables.Table and StructArrays.StructArray\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataTypes/#Base.getindex-Tuple{AbstractLegendInput, AbstractString, Vararg{Any}}","page":"LegendDataTypes","title":"Base.getindex","text":"getindex(input::AbstractLegendInput, key::AbstractString)\ngetindex(input::AbstractLegendInput, key::AbstractString, idxs::AbstractVector)\n\nGet object at key from input.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#Base.getindex-Tuple{LegendNullOutput, Any, AbstractString, Vararg{Any}}","page":"LegendDataTypes","title":"Base.getindex","text":"setindex!(output::AbstractLegendOutput, key::AbstractString)\ngetindex(output::AbstractLegendOutput, key::AbstractString, idxs::AbstractVector)\n\nGet object at key from input.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.chname2int-Tuple{AbstractString}","page":"LegendDataTypes","title":"LegendDataTypes.chname2int","text":"chname2int(channel_string::AbstractString)::Integer\n\nConvert a channel name string, as used in LEGEND data files to an integer channel number.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.decode_data","page":"LegendDataTypes","title":"LegendDataTypes.decode_data","text":"decode_data(data)\n\nDecode any encoded arrays present in (possibly nested) data.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.fast_flatten","page":"LegendDataTypes","title":"LegendDataTypes.fast_flatten","text":"fast_flatten(vector_of_arrays)\n\nFlattens a vector of arrays into a single array, by concatenating the inner arrays along the last dimension.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.filter_raw_data_by_energy-Tuple{AbstractVector{<:NamedTuple}, Function, AbstractDict{Symbol, <:IntervalSets.AbstractInterval{<:Number}}}","page":"LegendDataTypes","title":"LegendDataTypes.filter_raw_data_by_energy","text":"filter_raw_data_by_energy(\n    raw_data::TableLike,\n    calib_func::Function,\n    energy_windows::AbstractDict{Symbol,<:AbstractInterval{<:Number}}\n)::IDDict{Symbol,<:Any}\n\nFilter the table raw data, selecing only events in the energy intervals in values(energy_windows).\n\nThe selection is based on DAQ energy reconstruction and the energy calibration function calib_func.\n\nReturns a dicts of raw data tables with the same keys as energy_windows.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.flatten_by_key-Tuple{AbstractVector{<:IdDict{<:Any, <:AbstractVector}}}","page":"LegendDataTypes","title":"LegendDataTypes.flatten_by_key","text":"flatten_by_key(data::AbstractVector{<:IdDict{<:Any, <:AbstractVector}})::IdDict\n\nFlattens a vector of IdDicts into a single IdDict, by concatenating the entries for each key separately.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.get_all_channels-Tuple{AbstractDict{<:AbstractString}}","page":"LegendDataTypes","title":"LegendDataTypes.get_all_channels","text":"get_all_channels(ds::AbstractDict{<:AbstractString,<:Any})::AbstractVector{<:Integer}\n\nGet the channel numbers for all channels in datastore.\n\nChannels are identified as keys starting with \"ch...\", according to LEGEND convention. datastore will typically be on-disk, e.g. a LegendHDF5IO.LegendHDFLHDataStore.\n\nChannel named are mapped to integer channel numbers via chname2int.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.get_daqenergy-Tuple{AbstractDict{<:AbstractString}, Integer}","page":"LegendDataTypes","title":"LegendDataTypes.get_daqenergy","text":"get_daqenergy(datastore::AbstractDict{<:AbstractString,<:Any}, ch::Integer)::AbstractVector{<:Integer}\n\nGet the daq energy reconstruction contained in the raw data of channel ch in datastore.\n\ndatastore will typically be on-disk, e.g. a LegendHDF5IO.LegendHDFLHDataStore. Channel numbers are mapped to channel names via int2chname.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.get_raw_ch_data-Tuple{AbstractDict{<:AbstractString}, Integer}","page":"LegendDataTypes","title":"LegendDataTypes.get_raw_ch_data","text":"get_raw_ch_data(ds::AbstractDict{<:AbstractString,<:Any}, ch::Integer)::TableLike\n\nGet the raw data table for channel ch in datastore.\n\ndatastore will typically be on-disk, e.g. a LegendHDF5IO.LegendHDFLHDataStore. Channel numbers are mapped to channel names via int2chname.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.getunits","page":"LegendDataTypes","title":"LegendDataTypes.getunits","text":"getunits(x)\n\nGet the units of x, falls back to Unitful.unit(x) if no specialized method is defined for the type of x.\n\nLEGEND I/O packages shoud add methods for the I/O-object types they handle.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.int2chname-Tuple{Any}","page":"LegendDataTypes","title":"LegendDataTypes.int2chname","text":"int2chname(channel_number::Integer)::AbstractString\n\nConvert an integer channel number to a channel name string as used in LEGEND data files.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.map_chunked-Tuple{Any, Any, Integer}","page":"LegendDataTypes","title":"LegendDataTypes.map_chunked","text":"map_chunked(f, table, chunk_size::Integer)\n\nMaps a function f over a table in chunks of size chunk_size.\n\nCalls getindex with contiguous index ranges, and so is also efficient for disk-based arrays and similar arrays with slow serial indexing but fast block-wise indexing.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataTypes/#LegendDataTypes.read_from_properties","page":"LegendDataTypes","title":"LegendDataTypes.read_from_properties","text":"read_from_properties(read_property::Function, src::Any, ::Type{T}) where {T<:AbstractArrayCodec}\n\nCreate a array codec of type T from properties of src, using the src-specific function read_property(src, name::Symbol, default_value) to read each property required.\n\nReturns an value of type T.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.readdata","page":"LegendDataTypes","title":"LegendDataTypes.readdata","text":"readdata(input, SomeDataType::Type)\n\nRead a value of type SomeDataType from input.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.setunits!","page":"LegendDataTypes","title":"LegendDataTypes.setunits!","text":"setunits!(x)\n\nSet the units of x.\n\nLEGEND I/O packages will need to add methods for the I/O-object types they handle.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.to_properties","page":"LegendDataTypes","title":"LegendDataTypes.to_properties","text":"write_to_properties!(write_property!::Function, dest::Any, codec::AbstractArrayCodec)\n\nWrite all information required to re-create codec to dest using thes dest-specific function write_property!(dest, name::Symbol, x).\n\nTypically returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataTypes/#LegendDataTypes.writedata","page":"LegendDataTypes","title":"LegendDataTypes.writedata","text":"readdata(input, x::SomeDataType)\n\nWrite a value x to output.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDSP/#LegendDSP","page":"LegendDSP","title":"LegendDSP","text":"","category":"section"},{"location":"packages/LegendDSP/","page":"LegendDSP","title":"LegendDSP","text":"Also see LegendDSP on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendDSP/#Modules","page":"LegendDSP","title":"Modules","text":"","category":"section"},{"location":"packages/LegendDSP/","page":"LegendDSP","title":"LegendDSP","text":"Modules = [LegendDSP]\nOrder = [:module]","category":"page"},{"location":"packages/LegendDSP/#Types-and-constants","page":"LegendDSP","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendDSP/","page":"LegendDSP","title":"LegendDSP","text":"Modules = [LegendDSP]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendDSP/#Functions-and-macros","page":"LegendDSP","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendDSP/","page":"LegendDSP","title":"LegendDSP","text":"Modules = [LegendDSP]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendDSP/#Documentation","page":"LegendDSP","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendDSP/","page":"LegendDSP","title":"LegendDSP","text":"Modules = [LegendDSP]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendDSP/#LegendDSP.LegendDSP","page":"LegendDSP","title":"LegendDSP.LegendDSP","text":"LegendDSP\n\nTemplate for Julia packages.\n\n\n\n\n\n","category":"module"},{"location":"packages/LegendDSP/#LegendDSP.DSPConfig","page":"LegendDSP","title":"LegendDSP.DSPConfig","text":"DSPConfig{T <: Real}\n\nConfiguration parameters for DSP algorithms.\n\nFields\n\nenc_pickoff::Quantity{<:T}: pick-off time for ENC noise calculations\nbl_mean::NTuple{2, Quantity{<:T}}: fit window for basline extraction\npz_fit::NTuple{2, Quantity{<:T}}: fit window for decay time extraction\nt0_threshold::T: ADC threshold for t0 determination\ne_grid_rt_trap::StepRangeLen{Quantity{<:T}}: rise time grid scan range for trapezoidal filter\ne_grid_ft_trap::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for trapezoidal filter\ne_grid_rt_zac::StepRangeLen{Quantity{<:T}}: rise time grid scan range for ZAC filter\ne_grid_ft_zac::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for ZAC filter\ne_grid_rt_cusp::StepRangeLen{Quantity{<:T}}: rise time grid scan range for CUSP filter\ne_grid_ft_cusp::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for CUSP filter\ne_grid_rt_sg::StepRangeLen{Quantity{<:T}}: window length grid scan range for SG filter\n\nExamples\n\nusing LegendDSP\nusing Unitful\n\ndsp_config = DSPConfig{Float64}(32.0u\"µs\", \n(0.0u\"µs\", 39.0u\"µs\"), \n(80.0u\"µs\", 110.0u\"µs\"), \n5.0, \n7.0u\"µs\":0.5u\"µs\":12.0u\"µs\", 1.0u\"µs\":0.2u\"µs\":4.0u\"µs\",\n7.0u\"µs\":0.5u\"µs\":12.0u\"µs\", 1.0u\"µs\":0.2u\"µs\":4.0u\"µs\", \n7.0u\"µs\":0.5u\"µs\":12.0u\"µs\", 1.0u\"µs\":0.2u\"µs\":4.0u\"µs\")\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDSP/#LegendDSP.create_dsp_config","page":"LegendDSP","title":"LegendDSP.create_dsp_config","text":"create_dsp_config(dsp_metadata::PropDicts.PropDict)\n\nCreate a DSPConfig from a PropDict of DSP metadata.\n\nArguments\n\ndsp_metadata::PropDicts.PropDict: DSP metadata\n\nReturns\n\ndsp_config::DSPConfig: DSP configuration\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDSP/#LegendDSP.dsp_decay_times-Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig}","page":"LegendDSP","title":"LegendDSP.dsp_decay_times","text":"dsp_decay_times(wvfs::AbstractSamples, start::Real, stop::Real)\n\nGet statistics on the logarhithmic of the tail of the wvfs in the interval (start,stop).\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_sg_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_sg_optimization","text":"dsp_sg_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where T<:Real\n\nOptimize the Savitzky-Golay filter parameters for a given waveform set.\n\nReturns:     - aoe: Array of efficiency values for the given Savitzky-Golay filter parameters     - e: Array of energy values for the given Savitzky-Golay filter parameters     - blmean: Baseline mean value     - blslope: Baseline slope value\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_trap_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_trap_ft_optimization","text":"dsp_trap_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given trap grid rise times while varying the flat-top time.\n\nReturns:     - e_grid: Array energy values for the given trap rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.dsp_trap_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}, Tuple{StructArrays.StructArray{<:RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"LegendDSP","title":"LegendDSP.dsp_trap_rt_optimization","text":"dsp_trap_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}) where T<:Real\n\nGet ENC noise grid values for given trap grid rise times.\n\nReturns:     - enc_trap_grid: Array ENC noise values for the given trap rise time grid\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.extrema3points-Union{Tuple{T}, Tuple{T, T, T}} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real)","page":"LegendDSP","title":"LegendDSP.extrema3points","text":"extrema3points(y1::T,y2::T,y3::T)::T where {T<:AbstractFloat}\n\nCalculate the extrema of a parabola defined by three points.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDSP/#LegendDSP.get_wvf_maximum","page":"LegendDSP","title":"LegendDSP.get_wvf_maximum","text":"get_wvf_maximum(signal::AbstractSamples, start::Real, stop::Real)\nget_wvf_maximum(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet the maximum of a signal in the interval (start,stop) by quadaratic interpolation.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDSP/#LegendDSP.saturation","page":"LegendDSP","title":"LegendDSP.saturation","text":"tailstats(signal::AbstractSamples, start::Real, stop::Real)\ntailstats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet statistics on the logarhithmic of the tail of a signal in the interval (start,stop).\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDSP/#LegendDSP.tailstats","page":"LegendDSP","title":"LegendDSP.tailstats","text":"tailstats(signal::AbstractSamples, start::Real, stop::Real)\ntailstats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet statistics on the logarhithmic of the tail of a signal in the interval (start,stop).\n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationSpectra/#RadiationSpectra","page":"RadiationSpectra","title":"RadiationSpectra","text":"","category":"section"},{"location":"packages/RadiationSpectra/","page":"RadiationSpectra","title":"RadiationSpectra","text":"Also see RadiationSpectra on GitHub and the full package documentation.","category":"page"},{"location":"packages/RadiationSpectra/#Modules","page":"RadiationSpectra","title":"Modules","text":"","category":"section"},{"location":"packages/RadiationSpectra/","page":"RadiationSpectra","title":"RadiationSpectra","text":"Modules = [RadiationSpectra]\nOrder = [:module]","category":"page"},{"location":"packages/RadiationSpectra/#Types-and-constants","page":"RadiationSpectra","title":"Types and constants","text":"","category":"section"},{"location":"packages/RadiationSpectra/","page":"RadiationSpectra","title":"RadiationSpectra","text":"Modules = [RadiationSpectra]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/RadiationSpectra/#Functions-and-macros","page":"RadiationSpectra","title":"Functions and macros","text":"","category":"section"},{"location":"packages/RadiationSpectra/","page":"RadiationSpectra","title":"RadiationSpectra","text":"Modules = [RadiationSpectra]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/RadiationSpectra/#Documentation","page":"RadiationSpectra","title":"Documentation","text":"","category":"section"},{"location":"packages/RadiationSpectra/","page":"RadiationSpectra","title":"RadiationSpectra","text":"Modules = [RadiationSpectra]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/RadiationSpectra/#RadiationSpectra.calibrate_spectrum-Tuple{StatsBase.Histogram{<:Real, 1}, Vector{<:Real}}","page":"RadiationSpectra","title":"RadiationSpectra.calibrate_spectrum","text":"calibrate_spectrum(h_uncal::Histogram, photon_lines::Array{Real, 1}; <keyword arguments>)\n\nReturns the calibrated histogram, the deconvoluted spectrum, the found (uncalibrated) peak positions and the final threshold value.\n\nKeywords\n\nσ::Real = 2.0: The expected sigma of a peak in the spectrum. In units of bins.\nthreshold::Real = 10.0: Threshold for being identified as a peak in the deconvoluted spectrum. A single bin is identified as a peak when its weight exceeds the threshold and the previous bin was not identified as an peak.\nmin_n_peaks::Int = 0: If the number of found peaks is smaller than min_n_peaks the functions lowers the parameter threshold until enough peaks are found.\nmax_n_peaks::Int = 50: Use only the first (strongest) max_n_peaks peaks for peak identification.\nα::Real = 0.005:  = 0.5%. Acceptance level in the comparison of the peak position ratios in the peak indentification step. When the difference between the ratio of two found peak positions and the ratio of two photon lines (photon_lines) is smaller than α, the found peaks are identified as the two photon lines.\nrtol::Real = 5e-3:  = 5e-3. Acceptance level for tolerance of the absolute difference between true and found line position.\n\nCalibrate the spectrum h_uncal. This is done by:\n\nfinding peaks through devoncolution\nidentifying them through comparison of the ratios of their positions with the ratios of the known lines\nfitting all identified peaks (with a gaussian plus first order polynomial) to get their position more precisely\nperforme a linear fit (offset forced to 0) of these positions vs the true positions (lines) to get the calibration constant\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationSpectra/#RadiationSpectra.get_example_spectrum-Tuple{}","page":"RadiationSpectra","title":"RadiationSpectra.get_example_spectrum","text":"get_example_spectrum()::Histogram\n\nReturns an uncalibrated radiation spectrum for testing and demonstrating purpose.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationSpectra/#RadiationSpectra.opt_fit","page":"RadiationSpectra","title":"RadiationSpectra.opt_fit","text":"# opt_fit(DT::Type{<:UvSpectrumDensity}, h::Histogram{<:Any, 1},\n         p0::NamedTuple, lower_bounds::NamedTuple, upper_bounds::NamedTuple)\n\nMaximum Likelihood Estimation Fit of model density d on the histogram h.     \n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationSpectra/#RadiationSpectra.opt_fit-2","page":"RadiationSpectra","title":"RadiationSpectra.opt_fit","text":"# opt_fit(DT::Type{<:UvSpectrumDensity}, h::Histogram{<:Any, 1},\n         p0::AbstractVector, lower_bounds::AbstractVector, upper_bounds::AbstractVector)\n\nMaximum Likelihood Estimation Fit of model density d on the histogram h.     \n\n\n\n\n\n","category":"function"},{"location":"packages/RadiationSpectra/#RadiationSpectra.peakfinder-Tuple{StatsBase.Histogram}","page":"RadiationSpectra","title":"RadiationSpectra.peakfinder","text":"peakfinder(h::Histogram; <keyword arguments>)::Tuple{Histogram, Array{Float64, 1}}\n\nReturns a deconvoluted spectrum and an array of peak positions.\n\nKeywords\n\nσ::Real=2.0: The expected sigma of a peak in the spectrum. In units of bins. \nthreshold::Real=10.0: Threshold for being identified as a peak in the deconvoluted spectrum. A single bin is identified as a peak when its weight exceeds the threshold and the previous bin was not identified as an peak.\nbackgroundRemove::Bool=true\ndeconIterations::Int=3\nmarkov::Bool=true\naverWindow::Int=3\n\nSource\n\nThis function is basically a copy of TSpectrum::SearchHighRes from ROOT.\n\nM.A. Mariscotti: A method for identification of peaks in the presence of background and its application to spectrum analysis. NIM 50 (1967), 309-320.\nM. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.\nZ.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451.\n\n\n\n\n\n","category":"method"},{"location":"packages/RadiationDetectorSignals/#RadiationDetectorSignals","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"","category":"section"},{"location":"packages/RadiationDetectorSignals/","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"Also see RadiationDetectorSignals on GitHub and the full package documentation.","category":"page"},{"location":"packages/RadiationDetectorSignals/#Modules","page":"RadiationDetectorSignals","title":"Modules","text":"","category":"section"},{"location":"packages/RadiationDetectorSignals/","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"Modules = [RadiationDetectorSignals]\nOrder = [:module]","category":"page"},{"location":"packages/RadiationDetectorSignals/#Types-and-constants","page":"RadiationDetectorSignals","title":"Types and constants","text":"","category":"section"},{"location":"packages/RadiationDetectorSignals/","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"Modules = [RadiationDetectorSignals]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/RadiationDetectorSignals/#Functions-and-macros","page":"RadiationDetectorSignals","title":"Functions and macros","text":"","category":"section"},{"location":"packages/RadiationDetectorSignals/","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"Modules = [RadiationDetectorSignals]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/RadiationDetectorSignals/#Documentation","page":"RadiationDetectorSignals","title":"Documentation","text":"","category":"section"},{"location":"packages/RadiationDetectorSignals/","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals","text":"Modules = [RadiationDetectorSignals]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/RadiationDetectorSignals/#RadiationDetectorSignals.ArrayOfRDWaveforms","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals.ArrayOfRDWaveforms","text":"ArrayOfRDWaveforms = StructArray{<:RDWaveform, ...)\n\nA StructsArrays.StructArray of RDWaveform.\n\nBy default, uses ArraysOfArrays.VectorOfVectors for contiguous memory layout.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorSignals/#RadiationDetectorSignals.DetectorHit","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals.DetectorHit","text":"DetectorHit = NamedTuple{(:evtno, :detno, :thit, :edep, :pos), ...)\n\nRepresentation of an localized energy deposition in a detector.\n\nUse DetectorHitEvents for arrays of DetectorHit that have a compact memory layout.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorSignals/#RadiationDetectorSignals.DetectorHitEvents","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals.DetectorHitEvents","text":"DetectorHitEvents = TypedTables.Table{...}\n\nA TypedTables.Table of DetectorHit events.\n\n\n\n\n\n","category":"type"},{"location":"packages/RadiationDetectorSignals/#RadiationDetectorSignals.RDWaveform","page":"RadiationDetectorSignals","title":"RadiationDetectorSignals.RDWaveform","text":"RDWaveform\n\nRepresents a radiation detector signal waveform.\n\nFields:\n\ntime: time axis, typically a range\nsignal: detector signal values\n\nUse ArrayOfRDWaveforms for arrays of RDWaveform that have a compact memory layout.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"","category":"section"},{"location":"packages/LegendHDF5IO/","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"Also see LegendHDF5IO on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendHDF5IO/#Modules","page":"LegendHDF5IO","title":"Modules","text":"","category":"section"},{"location":"packages/LegendHDF5IO/","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"Modules = [LegendHDF5IO]\nOrder = [:module]","category":"page"},{"location":"packages/LegendHDF5IO/#Types-and-constants","page":"LegendHDF5IO","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendHDF5IO/","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"Modules = [LegendHDF5IO]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendHDF5IO/#Functions-and-macros","page":"LegendHDF5IO","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendHDF5IO/","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"Modules = [LegendHDF5IO]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendHDF5IO/#Documentation","page":"LegendHDF5IO","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendHDF5IO/","page":"LegendHDF5IO","title":"LegendHDF5IO","text":"Modules = [LegendHDF5IO]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array{T, N} <: AbstractArray{T, N}\n\nArray wrapper for HDF5.Datasets following the LEGEND data format as in \".lh5\" files. \n\nAn LH5Array contains a HDF5.Dataset file and Unitful.Unitlike units as  returned by getunits(file).getindexandappend!are supported.getindexessentially falls back togetindexforHDF5.Datasets,  enabling the user to always read in the desired part of an ondisk array without  having to load it in whole beforehand.append!` uses chunks to append the data provided to the ondisk array. It is important to note, that data is always appended along the last dimension of an  array\n\nDefault constructors\n\nLH5Array{T}(ds::HDF5.Dataset, u::Unitful.Unitlike)\nLH5Array{T, N}(ds::HDF5.Dataset)\nLH5Array(ds::Union{HDF5.Dataset, HDF5.H5DataStore})\n\n\nExamples:\n\njulia> using HDF5\njulia> f = h5open(\"path/to/lh5/file\", \"r\")\njulia> l5 = LH5Array(f[\"path/to/HDF5/Dataset\"])\n[...]\njulia> x = lh[1:10]     # load the first 10 elements of the ondisk array\n[...]\njulia> append!(lh, x)   # append those 10 elements to the ondisk array \n[...]\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:AbstractArray{<:Bool}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:AbstractArray{<:Bool}}) = begin\n\nreturn a LH5Array with dimensions equal to that of ds and element type  Bool. Applying getindex! on LH5Array{Bool} will yield a BitArray.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:AbstractArray{<:Tuple{Vararg{T, N}} where {N, T}}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:AbstractArray{<:Tuple}})\n\nreturn an Array of NTuples\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:AbstractArray}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:AbstractArray})\n\nreturn a LH5Array with dimensions equal to that of ds and element type  equal to eltype(ds) * u\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:ArraysOfArrays.AbstractArrayOfSimilarArrays{<:Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.H5DataStore, ::Type{<:AbstractArrayOfSimilarArrays{<:RealQuantity}})\n\nreturn an ArraysOfSimilarArrays where the field data is a LH5Array  (see ArraysOfSimilarArrays)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:Bool}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.H5DataStore, ::Type{<:Bool}) = begin\n\nreturn a value with type Bool\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:String}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:String})\n\nreturn a String.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:Symbol}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:Symbol})\n\nreturn a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:Tuple}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:Tuple})\n\nreturn an Tuple\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.Dataset, Type{<:Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:RealQuantity})\n\nreturn a value with type RealQuantity\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:AbstractVector{<:AbstractVector}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.DataStore, ::Type{<:AbstractVector{<:AbstractVector{<:RealQuantity}}})\n\nreturn a VectorOfVectors object where data is an LH5Array  (see VectorOfArrays)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:AbstractVector{<:RDWaveform}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.DataStore, ::Type{<:AbstractVector{<:RDWaveform}})\n\nreturn an ArrayOfRDWaveforms where the field signal is either a  VectorOfSimilarVectors with an LH5Array as data or VectorOfVectors  with an LH5Array as data (see ArrayOfRDWaveforms and ArraysOfArrays) \n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:EncodedArrays.AbstractEncodedArray{T, 1} where T}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.H5DataStore, ::Type{<:AbstractEncodedArray{T, 1} where {T}})\n\nreturn an EncodedArray\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:EncodedArrays.VectorOfEncodedArrays{T, 1, C, VS} where {T, C<:EncodedArrays.AbstractArrayCodec, VS<:(AbstractVector{<:Tuple{var\"#s12\"} where var\"#s12\"<:Integer})}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.H5DataStore, ::Type{<:VectorOfEncodedArrays{T, 1} where {T}})\n\nreturn a VectorOfEncodedArrays\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:EncodedArrays.VectorOfEncodedSimilarArrays{T, 1} where T}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.H5DataStore, ::Type{<:VectorOfEncodedSimilarArrays{T, 1} where {T}})\n\nreturn a VectorOfEncodedSimilarArrays\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Tuple{HDF5.H5DataStore, Type{<:StatsBase.Histogram{<:Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real}}}","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"\"     LH5Array(ds::HDF5.H5DataStore, ::Type{<:Histogram{<:RealQuantity}})\n\nreturn a Histogram. \n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Union{Tuple{T}, Tuple{HDF5.H5DataStore, Type{<:NamedTuple{T}}}} where T","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.Dataset, ::Type{<:NamedTuple{T}}) where T\n\nreturn a NamedTuple where each field is the output of LH5Array applied to it.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LH5Array-Union{Tuple{T}, Tuple{HDF5.H5DataStore, Type{<:TypedTables.Table{var\"#s18\", N} where {var\"#s18\"<:(NamedTuple{T}), N}}}} where T","page":"LegendHDF5IO","title":"LegendHDF5IO.LH5Array","text":"LH5Array(ds::HDF5.DataStore, ::Type{<:TypedTables.Table{<:NamedTuple{(T)}}}) where T\n\nreturn a Table where each column is the output of LH5Array applied to it.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.LHDataStore","page":"LegendHDF5IO","title":"LegendHDF5IO.LHDataStore","text":"LHDataStore <: AbstractDict{String,Any}\n\nDictionary wrapper for HDF5.H5DataStore objects, which were constructed  according to the LEGEND data format in \".lh5\" files. \n\nConstructor:\n\nLHDataStore(h5ds::HDF5.DataStore)\n\nThis return an LHDataStore object that wraps an h5ds which will typically be an HDF5.File be may also be an HDF5.H5DataStore (e.g. an HDF5.Group). in general.\n\nTo read or write \".lh5\" file directly (without using HDF5.h5open first), we recommend using lh5open.\n\nSupports getindex and setindex! where getindex(lh::LHDataStore, s) returns  the output of LH5Array applied to data_store[s] and setindex!  creates and writes HDF5.Groups and HDF5.Datasets using chunks of size 1000  to the ondisk array. Currently supported are objects with types: AbstractArray{<:RealQuantity}, ArraysOfSimilarArrays{<:RealQuantity},  VectorOfVectors{<:RealQuantity}, NamedTuple,TypedTables.Table,  Vector{<:RDWaveform}. For AbstractArray{<:RealQuantity} It is assumed  that the last axis of the provided array corresponds to the event number  index.\n\nExample\n\njulia> using HDF5\njulia> h5ds = h5open(\"path/to/lhf/file\")\njulia> lhf = LHDataStore(h5ds)\njulia> lhf[\"raw\"]\n[...]\njulia> using Unitful\njulia> x = rand(100) * u\"ns\"\njulia> lhf[\"new\"] = x\n[...]\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.add_entries!","page":"LegendHDF5IO","title":"LegendHDF5IO.add_entries!","text":"add_entries!(lhd::LHDataStore, i::AbstractString, src::NamedTuple, \n    dest::NamedTuple=LH5Array(lhd.data_store[i]))\n\nextend the NamedTuple dest at lhd[i] with elements from src.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.add_entries!-2","page":"LegendHDF5IO","title":"LegendHDF5IO.add_entries!","text":"add_entries!(lhd::LHDataStore, i::AbstractString, src::TypedTable.Table, \n    dest::TypedTable.Table=LH5Array(lhd.data_store[i]))\n\nextend the Table dest at lhd[i] with columns from src.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.delete_entry!-Tuple{LHDataStore, AbstractString}","page":"LegendHDF5IO","title":"LegendHDF5IO.delete_entry!","text":"delete_entry!(lhd::LHDataStore, i::AbstractString)\n\nremove the dataset lhd[i] and adjust the datatype of the parent if necessary.  Currently supported are elements of NamedTuple, TypedTable.Table or  HDF5.Group. \n\n\n\n\n\n","category":"method"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.lh5open","page":"LegendHDF5IO","title":"LegendHDF5IO.lh5open","text":"lh5open(f, filename::AbstractString, access::AbstractString = \"r\")\n\nReturn f(lh5open(f, filename, access)).\n\nOpens and closes the LEGEND HDF5 file filename automatically.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendHDF5IO/#LegendHDF5IO.lh5open-2","page":"LegendHDF5IO","title":"LegendHDF5IO.lh5open","text":"lh5open(filename::AbstractString, access::AbstractString = \"r\")\n\nOpen a LEGEND HDF5 file and return an LHDataStore object.\n\nLEGEND HDF5 files typically use the file extention \".lh5\".\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"packages/LegendDataManagement/#LegendDataManagement","page":"LegendDataManagement","title":"LegendDataManagement","text":"","category":"section"},{"location":"packages/LegendDataManagement/","page":"LegendDataManagement","title":"LegendDataManagement","text":"Also see LegendDataManagement on GitHub and the full package documentation.","category":"page"},{"location":"packages/LegendDataManagement/#Modules","page":"LegendDataManagement","title":"Modules","text":"","category":"section"},{"location":"packages/LegendDataManagement/","page":"LegendDataManagement","title":"LegendDataManagement","text":"Modules = [LegendDataManagement, LegendDataManagement.LDMUtils]\nOrder = [:module]","category":"page"},{"location":"packages/LegendDataManagement/#Types-and-constants","page":"LegendDataManagement","title":"Types and constants","text":"","category":"section"},{"location":"packages/LegendDataManagement/","page":"LegendDataManagement","title":"LegendDataManagement","text":"Modules = [LegendDataManagement, LegendDataManagement.LDMUtils]\nOrder = [:type, :constant]","category":"page"},{"location":"packages/LegendDataManagement/#Functions-and-macros","page":"LegendDataManagement","title":"Functions and macros","text":"","category":"section"},{"location":"packages/LegendDataManagement/","page":"LegendDataManagement","title":"LegendDataManagement","text":"Modules = [LegendDataManagement, LegendDataManagement.LDMUtils]\nOrder = [:macro, :function]","category":"page"},{"location":"packages/LegendDataManagement/#Documentation","page":"LegendDataManagement","title":"Documentation","text":"","category":"section"},{"location":"packages/LegendDataManagement/","page":"LegendDataManagement","title":"LegendDataManagement","text":"Modules = [LegendDataManagement, LegendDataManagement.LDMUtils]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"packages/LegendDataManagement/#LegendDataManagement.AbstractSetupData","page":"LegendDataManagement","title":"LegendDataManagement.AbstractSetupData","text":"abstract type AbstractSetupData\n\nSubtypes wrap SetupConfig for specific experiments.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ChannelId","page":"LegendDataManagement","title":"LegendDataManagement.ChannelId","text":"struct ChannelId <: DataSelector\n\nRepresents a LEGEND data channel.\n\nExample:\n\nch = ChannelId(1083204)\n# ch = ChannelId(98) # with old channel numbering\nch.no == 1083204\nstring(ch) == \"ch1083204\"\nChannelId(\"ch1083204\") == ch\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataCategory","page":"LegendDataManagement","title":"LegendDataManagement.DataCategory","text":"struct DataCategory <: DataSelector\n\nRepresents a LEGEND data category (related to a DAQ/measuring mode) like \"cal\" or \"phy\".\n\nExample:\n\ncategory = DataCategory(:cal)\ncategory.label == :cal\nstring(category) == \"cal\"\nDataCategory(\"cal\") == category\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataPartition","page":"LegendDataManagement","title":"LegendDataManagement.DataPartition","text":"struct DataPartition <: DataSelector\n\nRepresents a LEGEND data-taking partition.\n\nExample:\n\npartition = DataPartition(1)\npartition.no == 1\nstring(partition) == \"partition01\"\nDataPartition(\"partiton01\") == partition\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataPeriod","page":"LegendDataManagement","title":"LegendDataManagement.DataPeriod","text":"struct DataPeriod <: DataSelector\n\nRepresents a LEGEND data-taking period.\n\nExample:\n\nperiod = DataPeriod(2)\nperiod.no == 2\nstring(period) == \"p02\"\nDataPeriod(\"p02\") == period\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataRun","page":"LegendDataManagement","title":"LegendDataManagement.DataRun","text":"struct DataRun <: DataSelector\n\nRepresents a LEGEND data-taking run.\n\nExample:\n\nr = DataRun(6)\nr.no == 6\nstring(r) == \"r006\"\nDataRun(\"r006\") == r\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataSelector","page":"LegendDataManagement","title":"LegendDataManagement.DataSelector","text":"abstract type DataSelector\n\nAbstract type for data selectors like ExpSetup, DataTier, DataPeriod, DataRun, DataCategory, Timestamp and FileKey.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataTier","page":"LegendDataManagement","title":"LegendDataManagement.DataTier","text":"struct DataTier <: DataSelector\n\nRepresents a LEGEND data tier like \"raw, \"dsp\", etc.\n\nExample:\n\ntier = DataTier(:raw)\ntier.label == :raw\nstring(tier) == \"raw\"\nDataTier(\"raw\") == tier\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DetectorId","page":"LegendDataManagement","title":"LegendDataManagement.DetectorId","text":"struct DetectorId <: DataSelector\n\nRepresents a LEGEND detector id id.\n\nExample:\n\ndetector = DetectorId(:V99000A)\ndetector.label == :V99000A\nstring(detector) == \"V99000A\"\nDetectorId(\"V99000A\") == detector\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ExpSetup","page":"LegendDataManagement","title":"LegendDataManagement.ExpSetup","text":"struct ExpSetup <: DataSelector\n\nRepresents a LEGEND experimental setup like \"l200\".\n\nExample:\n\nsetup = ExpSetup(:l200)\nsetup.label == :l200\nstring(setup) == \"l200\"\nExpSetup(\"l200\") == setup\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.FileKey","page":"LegendDataManagement","title":"LegendDataManagement.FileKey","text":"struct FileKey <: DataSelector\n\nRepresents a LEGEND file key.\n\nExample:\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nSee also read_filekeys and write_filekeys.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LegendData","page":"LegendDataManagement","title":"LegendDataManagement.LegendData","text":"struct LegendData <: AbstractSetupData\n\nProvides access to LEGEND data and metadata.\n\nConstructors:\n\nLegendData(setup_config::SetupConfig).\nLegendData(setup::Symbol) - requires the $LEGEND_DATA_CONFIG environment variable to be set.\n\nExamples:\n\nconfig_filename = \"/path/to/config.json\"\nconfig = LegendDataConfig(config_filename)\nl200 = LegendData(config.setups.l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nor simply (if $LEGEND_DATA_CONFIG is set):\n\nl200 = LegendData(:l200)\n\nLegendData has the (virtual) properties metadata and tier.\n\nThe full path to \"tier\" data files can be retrieved using\n\n(data::LegendData)[tier::Symbol, filekey::FileKey]\n(data::LegendData).tier[tier::Symbol, filekey::AbstractString]\n\nExample:\n\nl200.tier[:raw]\nl200.tier[:raw, FileKey(\"l200-p02-r006-cal-20221226T200846Z\")]\n\nLegendData comes with an extension for SolidStateDetectors:\n\nl200 = LegendData(:l200)\nSolidStateDetector(l200, :V99000A)\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LegendDataConfig","page":"LegendDataManagement","title":"LegendDataManagement.LegendDataConfig","text":"struct LegendDataConfig\n\nData configuration multiple experimental setups.\n\nContains a single field setups::PropertyDict{Symbol,SetupConfig}.\n\nCan be read from a config file via LegendDataConfig(config_filename[s]), or simply LegendDataConfig() if the environment variable $LEGEND_DATA_CONFIG is set. $LEGEND_DATA_CONFIG may be a list of colon-separated config filenames, which are applied/merged in reverse order (analog to the order of prioritiy in $PATH and similar).\n\nExample:\n\nconfig = LegendDataConfig(\"/path/to/config.json\")\nsetup = config.setups.l200\ndata_path(setup, \"tier\", \"raw\", \"cal\", \"p02\", \"r006\", \"l200-p02-r006-cal-20221226T200846Z-tier_raw.lh5\")\n\nSee also SetupConfig.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LegendReport","page":"LegendDataManagement","title":"LegendDataManagement.LegendReport","text":"struct LegendReport\n\nRepresents a LEGEND report.\n\nDon't instantiate directly, use lreport()\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LegendTierData","page":"LegendDataManagement","title":"LegendDataManagement.LegendTierData","text":"struct LegendDataManagement.LegendTierData\n\nConstructors:\n\n(data::LegendData).tier\n\nLegendDataManagement.LegendTierData(data::LegendData)\n\nThe path to data directories and files can be accessed via getindex on tier_data::LegendTierData:\n\ntier_data[]\ntier_data[tier::DataTierLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike, run::DataRunLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike, run::DataRunLike, ch::ChannelIdLike]\n\ntier_data[tier::DataTierLike, filekey::FileKeyLike]\ntier_data[tier::DataTierLike, filekey::FileKeyLike, ch::ChannelIdLike]\n\nExamples:\n\n```julia l200 = LegendData(:l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\") isfile(l200.tier[:raw, filekey])\n\nisdir(l200.tier[:raw, :cal]) isdir(l200.tier[:raw, :cal, \"p02\"]) isdir(l200.tier[:raw, :cal, \"p02\", \"r006\"]) isdir(l200.tier[DataTier(:raw), DataCategory(:cal), DataPeriod(2), DataRun(6)])\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.NoSuchPropsDBEntry","page":"LegendDataManagement","title":"LegendDataManagement.NoSuchPropsDBEntry","text":"struct LegendDataManagement.NoSuchPropsDBEntry\n\nIndicates that a given property (path) of a LegendDataManagementPropsDB[@ref] does not exist.\n\nSupports PropDicts.writeprops(missing_props::NoSuchPropsDBEntry, props::PropDicts.PropDict) to create the missing directories and file for the property path.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ProcessStatus","page":"LegendDataManagement","title":"LegendDataManagement.ProcessStatus","text":"@enum ProcessStatus\n\nMay be succeeded, pending, or failed.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.PropsDB","page":"LegendDataManagement","title":"LegendDataManagement.PropsDB","text":"struct LegendDataManagement.PropsDB\n\nA PropsDB instance, e.g. myprops, presents an on-disk directory containing JSON files or sub-directories (that contains JSON files in leaf directories) as a dictionary of properties.\n\nPropsDB supports Base.keys and Base.getindex as well as Base.propertynames and Base.getproperty to access it's contents. getindex and getproperty will return either another PropsDB or a PropDicts.PropDict, depending on whether the accessed property is stored as a sub-directory or a JSON file. We recommend to use getproperty where the properties/keys of the PropDict are more or less standardized and where they may be arbitrary (see examples below).\n\nThe contents of PropsDB may be time- and category-dependent, determined by the presence of a \"validity.json\" file. In this case, use myprops(sel::LegendDataManagement.ValiditySelection) or myprops(filekey::FileKey) to select the desired time and category. The selection can be made at some point during traversal of properties or at the leaf PropsDB (see the examples below).\n\nExamples:\n\nl200 = LegendData(:l200)\n\npropertynames(l200.metadata.hardware)\nl200.metadata.hardware.detectors.germanium\n\nkeys(l200.metadata.hardware.detectors.germanium.diodes)\nl200.metadata.hardware.detectors.germanium.diodes[:V99000A]\n\ndiodes = l200.metadata.hardware.detectors.germanium.diodes\ndiodes[keys(diodes)]\n\nsel = ValiditySelection(\"20221226T194007Z\", :cal)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T194007Z\")\ndata.metadata.hardware(sel).configuration.channelmaps\ndata.metadata.hardware.configuration.channelmaps(filekey)\n\nUse code should not instantiate PropsDB directly, use  LegendDataManagement.AnyProps(path::AbstractString) instead, which may return a PropsDB or a PropDicts.PropDict depending on what on-disk content path points to. \n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.RunCategorySelLike","page":"LegendDataManagement","title":"LegendDataManagement.RunCategorySelLike","text":"struct RunCategorySelLike = Tuple{<:DataPeriodLike, <:DataRunLike}\n\nRepresents a LEGEND run selection for a specific category.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.RunSelLike","page":"LegendDataManagement","title":"LegendDataManagement.RunSelLike","text":"struct RunSelLike = Tuple{<:DataPeriodLike, <:DataRunLike}\n\nRepresents a LEGEND run selection.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.SetupConfig","page":"LegendDataManagement","title":"LegendDataManagement.SetupConfig","text":"struct SetupConfig\n\nData configuration for an experimental setup.\n\nSupports\n\ndata_path(setup, path_components)\n\nExamples:\n\ndata_path(setup, \"tier\", \"raw\", \"cal\", \"p02\", \"r006\", \"l200-p02-r006-cal-20221226T200846Z-tier_raw.lh5\")\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.Timestamp","page":"LegendDataManagement","title":"LegendDataManagement.Timestamp","text":"struct Timestamp <: DataSelector\n\nRepresents a LEGEND timestamp.\n\nExample:\n\njulia timestamp = Timestamp(\"20221226T200846Z\") timestamp.unixtime == 1672085326 string(timestamp) == \"20221226T200846Z\"`\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ValiditySelection","page":"LegendDataManagement","title":"LegendDataManagement.ValiditySelection","text":"struct LegendDataManagement.ValiditySelection\n\nRepresenty validiy selection for a LegendDataManagement.PropsDB[@ref].\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.AnyProps","page":"LegendDataManagement","title":"LegendDataManagement.AnyProps","text":"LegendDataManagement.AnyProps = Union{LegendDataManagement.PropsDB,PropDicts.PropDict}\n\nProperties stored either in a directory managed via [LegendDataManagement.PropsDB][@ref] or loaded from one or several files into a PropDicts.PropDict.\n\nConstructors:\n\nLegendDataManagement.AnyProps(base_path::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.AnyValiditySelection","page":"LegendDataManagement","title":"LegendDataManagement.AnyValiditySelection","text":"const AnyValiditySelection = Union{ValiditySelection,FileKey}\n\nAnything that can be used in time/category-based data selection.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ChannelIdLike","page":"LegendDataManagement","title":"LegendDataManagement.ChannelIdLike","text":"ChannelIdLike = Union{ChannelId, Integer, AbstractString}\n\nAnything that can represent a data channel, like ChannelId(1083204) or \"ch1083204\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataCategoryLike","page":"LegendDataManagement","title":"LegendDataManagement.DataCategoryLike","text":"DataCategoryLike = Union{DataCategory, Symbol, AbstractString}\n\nAnything that can represent a data category, like DataCategory(:cal), :cal or \"cal\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataPartitionLike","page":"LegendDataManagement","title":"LegendDataManagement.DataPartitionLike","text":"DataPartitionLike = Union{DataPartition, Symbol, AbstractString}\n\nAnything that can represent a data partition, like DataPartition(2) or \"partition02\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataPeriodLike","page":"LegendDataManagement","title":"LegendDataManagement.DataPeriodLike","text":"DataPeriodLike = Union{DataPeriod, Symbol, AbstractString}\n\nAnything that can represent a data period, like DataPeriod(2) or \"p02\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataRunLike","page":"LegendDataManagement","title":"LegendDataManagement.DataRunLike","text":"DataRunLike = Union{DataRun, Symbol, AbstractString}\n\nAnything that can represent a data run, like DataRun(6) or \"r006\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DataTierLike","page":"LegendDataManagement","title":"LegendDataManagement.DataTierLike","text":"DataTierLike = Union{DataTier, Symbol, AbstractString}\n\nAnything that can represent a data tier, like DataTier(:raw), :raw or \"raw\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.DetectorIdLike","page":"LegendDataManagement","title":"LegendDataManagement.DetectorIdLike","text":"DetectorIdLike = Union{DetectorId, Symbol, AbstractString}\n\nAnything that can represent a detector id.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ExpSetupLike","page":"LegendDataManagement","title":"LegendDataManagement.ExpSetupLike","text":"ExpSetupLike = Union{ExpSetup, Symbol, AbstractString}\n\nAnything that can represent a setup label, like ExpSetup(:l200), :l200 or \"l200\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.FileKeyLike","page":"LegendDataManagement","title":"LegendDataManagement.FileKeyLike","text":"FileKeyLike = Union{FileKey, AbstractString}\n\nAnything that can represent a file key, like FileKey(\"l200-p02-r006-cal-20221226T200846Z\") or \"l200-p02-r006-cal-20221226T200846Z\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LJlExprLike","page":"LegendDataManagement","title":"LegendDataManagement.LJlExprLike","text":"const LJlExprLike = Union{Expr, Symbol, Integer, AbstractFloat}\n\nAnything that can represent a parsed LEGEND Julia expression.\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.TimestampLike","page":"LegendDataManagement","title":"LegendDataManagement.TimestampLike","text":"TimestampLike = Union{Timestamp, AbstractString, Integer}\n\nAnything that can represent a timestamp, like Timestamp(\"20221226T200846Z\") or \"20221226T200846Z\".\n\n\n\n\n\n","category":"type"},{"location":"packages/LegendDataManagement/#LegendDataManagement.@always_everywhere-Tuple{Any}","page":"LegendDataManagement","title":"LegendDataManagement.@always_everywhere","text":"always_everywhere(expr)\n\nRuns expr on all current Julia processes, but also all future Julia processes added via legend_addprocs).\n\nSimilar to Distributed.everywhere, but also stores expr so that legend_addprocs can execute it automatically on new worker processes.\n\n\n\n\n\n","category":"macro"},{"location":"packages/LegendDataManagement/#LegendDataManagement.analysis_runs-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.analysis_runs","text":"analysis_runs(data::LegendData)\n\nReturn cross-period analysis runs.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.atomic_fcreate-Tuple{Any, Vararg{AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.atomic_fcreate","text":"function atomic_fcreate(\n    body, filenames::AbstractString...;\n    create_dirs::Bool = true, overwrite::Bool = true, delete_on_error::Bool=true\n)\n\nCreates filenames in an atomic fashion.\n\nCreates temporary files in the same directories as filenames, then calls body(temporary_filenames...). If body returns successfully, the files temporary_filenames are renamed to filenames. If body throws an exception, the temporary files are either deleted (if delete_on_error is true) or left in place (e.g. for debugging purposes).\n\nIf create_dirs is true, directories are created if necessary.\n\nIf all of files already exist and overwrite is false, takes no action (or, if the file is created by other code running in parallel, while body is running, does not overwrite it).\n\nThrows an error if only some of the files exist and overwrite is false.\n\nReturns nothing.\n\nExample:\n\natomic_fcreate(\"foo.txt\", \"bar.txt\") do foo, bar\n    write(foo, \"Hello\")\n    write(bar, \"World\")\nend\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.bad_filekeys-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.bad_filekeys","text":"bad_filekeys(data::LegendData)\n\nGet the list of filekeys to ignore for data.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.channelinfo-Tuple{LegendData, AnyValiditySelection}","page":"LegendDataManagement","title":"LegendDataManagement.channelinfo","text":"channelinfo(data::LegendData, sel::AnyValiditySelection; system::Symbol = :all, only_processable::Bool = false)\nchannelinfo(data::LegendData, sel::RunCategorySelLike; system::Symbol = :all, only_processable::Bool = false)\n\nGet all channel information for the given LegendData and ValiditySelection.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.channelinfo-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}, Union{ChannelId, AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.channelinfo","text":"channelinfo(data::LegendData, sel::AnyValiditySelection, channel::ChannelIdLike)\nchannelinfo(data::LegendData, sel::AnyValiditySelection, detector::DetectorIdLike)\n\nGet channel information validitiy selection and DetectorId resp. ChannelId.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.data_path","page":"LegendDataManagement","title":"LegendDataManagement.data_path","text":"data_path(setup::SetupConfig, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components as configured for setup.\n\nConverts between \"/\" and \"\\\" inside of path_components if necessary (for Windows compatibility).\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.data_path-Tuple{LegendDataManagement.AbstractSetupData, Vararg{AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.data_path","text":"data_path(setup::AbstractSetupData, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components as configured for setup.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.data_path-Tuple{LegendDataManagement.LegendTierData, Vararg{AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.data_path","text":"data_path(tier_data::LegendTierData, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components relative to tier_data.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.data_path-Tuple{LegendDataManagement.PropsDB}","page":"LegendDataManagement","title":"LegendDataManagement.data_path","text":"data_path(pd::LegendDataManagement.PropsDB)\n\nReturn the path to the data directory that contains pd.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.dataprod_config-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.dataprod_config","text":"dataprod_config(data::LegendData)\n\nGet the Julia data production configuration for data.\n\nUse dataprod_config(data)(valsel::AnyValiditySelection) to also set the time/category validity selection for the configuration.\n\nExamples:\n\nl200 = LegendData(:l200)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\ndataprod_config(l200)(filekey)\n\nor\n\nl200 = LegendData(:l200)\nvsel = ValiditySelection(\"20221226T200846Z\", :cal)\ndataprod_config(l200)(vsel)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.dataprod_parameters-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.dataprod_parameters","text":"dataprod_parameters(data::LegendData)\n\nGet the Julia data production parameters data.\n\nExamples:\n\nl200 = LegendData(:l200)\ndataprod_config(l200)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.dataprod_pars_aoe_window-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.dataprod_pars_aoe_window","text":"LegendDataManagement.dataprod_pars_aoe_window(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the A/E cut window for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_cal_propfunc","text":"get_ged_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the HPGe calibration function for the given data, validity selection and detector.\n\nNote: Caches configuration/calibration data internally, use a fresh data object if on-disk configuration/calibration data may have changed.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_qc_cuts_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_qc_cuts_propfunc","text":"get_ged_qc_cuts_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the Ge-detector QC cut definitions for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_qc_is_baseline_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_qc_is_baseline_propfunc","text":"get_ged_qc_is_baseline_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet a PropertyFunction that returns true for events that fullfill the is_baseline definition.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_qc_is_physical_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_qc_is_physical_propfunc","text":"get_ged_qc_is_physical_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet a PropertyFunction that returns true for events that fullfill the is_physical definition.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_ged_qc_is_trig_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_ged_qc_is_trig_propfunc","text":"get_ged_qc_istrig_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the Ge-detector trigger condition for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_pulser_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_pulser_cal_propfunc","text":"get_pulser_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the pulser calibration function for the given data, validity selection and the pulser channel referred to by detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_setup_config","page":"LegendDataManagement","title":"LegendDataManagement.get_setup_config","text":"LegendDataManagement.get_setup_config(data::AbstractSetupData)::SetupConfig\n\nMust be specialized for each subtype of AbstractSetupData.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_spm_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"LegendDataManagement","title":"LegendDataManagement.get_spm_cal_propfunc","text":"get_spm_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the LAr/SPMS calibration function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_uncertainties","page":"LegendDataManagement","title":"LegendDataManagement.get_uncertainties","text":"get_uncertainties(x::Unitful.Quantity{<:Measurements.Measurement{<:Real}})\nget_uncertainties(x::Unitful.Quantity{<:Real})\nget_uncertainties(pd::PropDict)\nget_uncertainties(A::AbstractArray)\n\nGet the uncertainty of a Unitful.Quantity or Measurements.Measurement object or a PropDict or an array of Unitful.Quantity or Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.get_values","page":"LegendDataManagement","title":"LegendDataManagement.get_values","text":"get_values(x::Unitful.Quantity{<:Measurements.Measurement{<:Real}})\nget_values(x::Unitful.Quantity{<:Real})\nget_values(pd::PropDict)\nget_values(A::AbstractArray)\n\nGet the value of a Unitful.Quantity or Measurements.Measurement object or a PropDict or an array of Unitful.Quantity or Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.is_analysis_run-Tuple{LegendData, DataPeriodLike, Union{DataRun, AbstractString, Symbol}}","page":"LegendDataManagement","title":"LegendDataManagement.is_analysis_run","text":"is_analysis_run(data::LegendData, period::DataPeriod, run::DataRun)\n\nReturn true if run is an analysis run for data in period.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.legend_addprocs","page":"LegendDataManagement","title":"LegendDataManagement.legend_addprocs","text":"legend_addprocs()\nlegend_addprocs(nprocs::Integer)\n\nAdd Julia worker processes for LEGEND data processing.\n\nAutomatically chooses between\n\nAdding processes on the current host\nAdding processes via SLURM (when in an salloc or sbatch) environment\n\nEnsures that all workers processes use the same Julia project environment as the current process. Requires that file systems paths are consistenst across compute hosts.\n\nUse @always_everywhere to run initialization code on all current processes and all future processes added via legend_addprocs:\n\nusing Distributed, LegendDataManagement\n\n@always_everywhere begin\n    using SomePackage\n    import SomeOtherPackage\n\n    get_global_value() = 42\nend\n\n# ... some code ...\n\nlegend_addprocs()\n\n# `get_global_value` is available even though workers were added later:\nremotecall_fetch(get_global_value, last(workers()))\n\nSee also LegendDataManagement.worker_resources() and LegendDataManagement.shutdown_workers_atexit().\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.legend_distributed_pinthreads-Tuple{AbstractVector{<:Integer}}","page":"LegendDataManagement","title":"LegendDataManagement.legend_distributed_pinthreads","text":"LegendDataManagement.legend_distributed_pinthreads(procs::AbstractVector{<:Integer})\n\nUse default thread-pinning strategy on processes procs.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.legend_pinthreads-Tuple{}","page":"LegendDataManagement","title":"LegendDataManagement.legend_pinthreads","text":"pinthreads_default()\n\nUse default thread-pinning strategy.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.livetime-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"LegendDataManagement","title":"LegendDataManagement.livetime","text":"phy_livetime(data::LegendData, runsel::RunSelLike)\n\nGet the livetime for data in physics data taking of run in period.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ljl_propfunc","page":"LegendDataManagement","title":"LegendDataManagement.ljl_propfunc","text":"ljl_propfunc(expr::LJlExprLike)\nljl_propfunc(expr_string::AbstractString)\n\nCompiles a PropertyFunctions.PropertyFunction from a LEGEND Julia expression.\n\nSee also parse_lpyexpr.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.ljl_propfunc-Tuple{AbstractDict{Symbol, <:Union{AbstractFloat, Expr, Integer, Symbol}}}","page":"LegendDataManagement","title":"LegendDataManagement.ljl_propfunc","text":"ljl_propfunc(expr_map::AbstractDict{Symbol,<:LJlExprLike})\nljl_propfunc(expr_map::AbstractDict{Symbol,<:AbstractString})\nljl_propfunc(expr_map::PropDict)\n\nCompiles a map between output field-names and LEGEND Julia expressions to a single PropertyFunctions.PropertyFunction.\n\nThe generated function will return NamedTuples with the same property names as the keys of expr_map.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.lpy_propfunc-Tuple{AbstractString}","page":"LegendDataManagement","title":"LegendDataManagement.lpy_propfunc","text":"lpy_propfunc(expr_string::AbstractString)::PropertyFunctions.PropertyFunction\n\nGenerate a PropertyFunctions.PropertyFunction from a LEGEND Python expression.\n\nSee also parse_lpyexpr and ljl_propfunc.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.lreport","page":"LegendDataManagement","title":"LegendDataManagement.lreport","text":"lreport()\nlreport(contents...)\n\nGenerate a LEGEND report, e.g. a data processing report.\n\nUse lreport!(rpt, contents...) to add more content to a report.\n\nExample:\n\nusing LegendDataManagement, StructArrays, IntervalSets, Plots\n\ntbl = StructArray(\n    col1 = rand(5), col2 = ClosedInterval.(rand(5), rand(5).+1),\n    col3 = [rand(3) for i in 1:5], col4 = ProcessStatus.(rand(-1:1, 5)),\n    col5 = [:a, :b, :c, :d, :e], col6 = [\"a\", \"b\", \"c\", \"d\", \"e\"],\n    col7 = [:(a[1]), :(a[2]), :(a[3]), :(a[4]), :(a[5])]\n)\n\nrpt = lreport(\n    \"# New report\",\n    \"Table 1:\", tbl\n)\nlreport!(rpt, \"Figure 1:\", stephist(randn(10^3)))\nlreport!(rpt, \"Figure 2:\", histogram2d(randn(10^4), randn(10^4), format = :png))\n\nshow(stdout, MIME\"text/plain\"(), rpt)\nshow(stdout, MIME\"text/html\"(), rpt)\nshow(stdout, MIME\"text/markdown\"(), rpt)\n\nwritelreport(\"report.txt\", rpt)\nwritelreport(\"report.html\", rpt)\nwritelreport(\"report.md\", rpt)\n\nSee LegendDataManagement.lreport_for_show! for how to specialize the behavior of show for specific report content types.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.lreport!","page":"LegendDataManagement","title":"LegendDataManagement.lreport!","text":"lreport!(rpt::LegendReport, contents...)\n\nAdd more content to report rpt. See lreport for an example.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.lreport_for_show!","page":"LegendDataManagement","title":"LegendDataManagement.lreport_for_show!","text":"LegendDataManagement.lreport_for_show!(rpt::LegendReport, mime::MIME, content)\n\nAdd the contents of content to rpt in a way that is optimized for being displayed (e.g. via show) with the given mime type.\n\nshow(output, mime, rpt) first transforms rpt by converting all contents of rpt using lreport_for_show!(rpt::LegendReport, mime, content).\n\nDefaults to lreport!(rpt, content), except for tables (Tables.istable(content) == true), which are converted to Markdown tables by default for uniform appearance.\n\nlreport_for_show! is not inteded to be called by users, but to be specialized for specific types of content content. Content types not already supported will primarily require specialization of\n\nlreport_for_show!(rpt::LegendReport, ::MIME\"text/markdown\", content::SomeType)\n\nIn some cases it may be desireable to specialize lreport_for_show! for MIME types like MIME\"text/html\" and MIME\"text/plain\" as well.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.map_datafiles-Tuple{Any, Any, LegendData, DataCategoryLike, AbstractVector{<:FileKey}}","page":"LegendDataManagement","title":"LegendDataManagement.map_datafiles","text":"map_datafiles(\n    f_process, f_open, data::LegendData,\n    category::DataCategoryLike, filekeys::AbstractVector{<:FileKey}\n)\n\nProcesses all filekeys in data for category.\n\nOpens the files using f_open and processes them using f_process.\n\nReturns a @NamedTuple{result::Dict{Filekey}, failed::Dict{Filekey}, success::Bool}:\n\nvalues(result) contains the results f_process(f_open(filename)) for  all filenames referred to by category and filekeys.\nvalues(result) contains the error where processing failed.\nsuccess equals isempty(failed)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.parse_ljlexpr-Tuple{AbstractString}","page":"LegendDataManagement","title":"LegendDataManagement.parse_ljlexpr","text":"parse_ljlexpr(expr_string::AbstractString)::LJlExprLike\n\nParse an LEGEND Julia expression and return a Julia syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.parse_lpyexpr-Tuple{AbstractString}","page":"LegendDataManagement","title":"LegendDataManagement.parse_lpyexpr","text":"parse_lpyexpr(expr_string::AbstractString)::LJlExprLike\n\nParse an expression compatible with the LEGEND Python software and return a Julia syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.partitioninfo","page":"LegendDataManagement","title":"LegendDataManagement.partitioninfo","text":"partitioninfo(data::LegendData, label::Symbol = :default)\n\nReturn cross-period data partitions.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.process_ljlexpr","page":"LegendDataManagement","title":"LegendDataManagement.process_ljlexpr","text":"process_ljlexpr(expr::LJlExprLike, f_varsubst = identity)::LJlExprLike\n\nVerify that expr is a valid LEGEND Julia expression and return it, with modifications if necessary.\n\nOptionally substitute variables in expr using f_varsubst.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.pydataprod_config-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.pydataprod_config","text":"pydataprod_config(data::LegendData)\n\nGet the Python data production configuration for data.\n\nUse pydataprod_config(data)(valsel::AnyValiditySelection) to also set the time/category validity selection for the configuration.\n\nExamples:\n\nl200 = LegendData(:l200)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\npydataprod_config(l200)(filekey)\n\nor\n\nl200 = LegendData(:l200)\nvsel = ValiditySelection(\"20221226T200846Z\", :cal)\npydataprod_config(l200)(vsel)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.pydataprod_parameters-Tuple{LegendData}","page":"LegendDataManagement","title":"LegendDataManagement.pydataprod_parameters","text":"pydataprod_parameters(data::LegendData)\n\nGet the Julia data production parameters data.\n\nExamples:\n\nl200 = LegendData(:l200)\ndataprod_config(l200)\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.read_filekeys-Tuple{AbstractString}","page":"LegendDataManagement","title":"LegendDataManagement.read_filekeys","text":"read_filekeys(filename::AbstractString)::AbstractVector{FileKey}\n\nReads a list of FileKey from a text file, one file key per line.\n\nIgnores empty lines. # may be used to start a comment in the file.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.readlprops","page":"LegendDataManagement","title":"LegendDataManagement.readlprops","text":"readlprops(filename::AbstractString)\nreadprops(filenames::Vector{<:AbstractString})\n\nRead a PropDict from a file and parse it to Unitful.Quantity and Measurements.Measurement objects.\n\nReturns\n\npd::PropDict with all :val fields converted to Unitful.Quantity objects and all :val fields converted to Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.runinfo-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"LegendDataManagement","title":"LegendDataManagement.runinfo","text":"runinfo(data::LegendData, runsel::RunSelLike)::NamedTuple\n\nGet the run information for data in runsel.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.search_disk","page":"LegendDataManagement","title":"LegendDataManagement.search_disk","text":"search_disk(::Type{<:DataSelector}, path::AbstractString)\n\nSearch on-disk data for data categories, periods, runs, and filekeys.\n\nExamples:\n\nl200 = LegendData(:l200)\n\nsearch_disk(DataCategory, l200.tier[:raw])\nsearch_disk(DataPeriod, l200.tier[:raw, :cal])\nsearch_disk(DataRun, l200.tier[:raw, :cal, \"p02\"])\nsearch_disk(FileKey, l200.tier[DataTier(:raw), :cal, DataPeriod(2), \"r006\"])\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.shutdown_workers_atexit-Tuple{}","page":"LegendDataManagement","title":"LegendDataManagement.shutdown_workers_atexit","text":"LegendDataManagement.shutdown_workers_atexit()\n\nEnsure worker processes are shut down when Julia exits.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.start_filekey-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"LegendDataManagement","title":"LegendDataManagement.start_filekey","text":"start_filekey(data::LegendData, runsel::RunCategorySelLike)\n\nGet the starting filekey for data in period, run, category.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.tmp_filename-Tuple{AbstractString}","page":"LegendDataManagement","title":"LegendDataManagement.tmp_filename","text":"LegendDataManagement.tmp_filename(fname::AbstractString)\n\nReturns a temporary filename, based on fname, in the same directory.\n\nDoes not create the temporary file.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.worker_resources-Tuple{}","page":"LegendDataManagement","title":"LegendDataManagement.worker_resources","text":"LegendDataManagement.worker_resources\n\nGet the distributed Julia process resources currently available.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.write_filekeys-Tuple{AbstractString, AbstractVector{<:FileKey}}","page":"LegendDataManagement","title":"LegendDataManagement.write_filekeys","text":"write_filekeys(filename::AbstractString, filekeys::AbstractVector{<:FileKey})\n\nWrites a list of FileKey to a text file, one file key per line.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.writelprops","page":"LegendDataManagement","title":"LegendDataManagement.writelprops","text":"writelprops(f::IO, p::PropDict; write_units::Bool=true, write_errors::Bool=true, mutliline::Bool=true, indent::Int=4)\nwritelprops(filename::AbstractString, p::PropDict; multiline::Bool=true, indent::Int=4)\nwritelprops(db::PropsDB, key::Union{Symbol, DataSelector}, p::PropDict; kwargs...)\n\nWrite a PropDict to a file and strip it to :val and :unit fields and :val and :err fields.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.writelreport","page":"LegendDataManagement","title":"LegendDataManagement.writelreport","text":"writelreport(filename::AbstractString, rpt::LegendReport)\nwritelreport(filename::AbstractString, mime::MIME, rpt::LegendReport)\n\nWrite lreport rpt to file filename.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.create_metadatatbl","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.create_metadatatbl","text":"create_metadatatbl(filekey::FileKey)\ncreate_metadatatbl(filekey::FileKey, part::DataPartitionLike)\n\nCreate a metadata table for a given filekey which can be added in a report.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.create_pars-Tuple{PropDicts.PropDict, Any}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.create_pars","text":"create_pars(pd::PropDict, result::Dict{ChannelInfo, ChannelResult}) -> PropDict\n\nCreate a PropDict from a result of the parallel processing\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_hitchfilename-Tuple{LegendData, ExpSetupLike, DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike, Union{ChannelId, AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_hitchfilename","text":"get_hitchfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike)\nget_hitchfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike)\n\nGet the filename for the hitch data for a given channel.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_logfilename","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_logfilename","text":"get_logfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, process::Symbol)\n\nGet the filename for the log file for a given setup, period, run, category and process.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_logfolder","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_logfolder","text":"get_logfolder(data::LegendData, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike)\n\nGet the folder for the log files for a given period, run and category.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_mltrainfilename","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_mltrainfilename","text":"get_mltrainfilename(data::LegendData, period::DataPeriodLike, category::DataCategoryLike)\nget_mltrainfilename(data::LegendData, filekey::FileKey)\n\nGet the filename for the machine learning training data.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_partitionfilekeys-Tuple{LegendData, DataPartitionLike, DataTierLike, DataCategoryLike}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_partitionfilekeys","text":"get_partitionfilekeys(data::LegendData, part::DataPartitionLike, tier::DataTierLike, category::DataCategoryLike; only_good::Bool=true)\n\nGet filekeys for a given partition.\n\nArguments\n\ndata::LegendData: data object\npart::DataPartitionLike: partition to be searched in\ntier::DataTierLike: tier\ncategory::DataCategoryLike: category\nonly_good::Bool=true: only get good filekeys\n\nReturn\n\nVector{FileKey}: filekeys\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_peaksfilename-Tuple{LegendData, ExpSetupLike, DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike, Union{ChannelId, AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_peaksfilename","text":"get_peaksfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike)\nget_peaksfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike)\n\nGet the filename for the peaks data for a given channel.\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_plottitle","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_plottitle","text":"get_plottitle(setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, det::DetectorIdLike, process::String; additiional_type::String=\"\")\nget_plottitle(filekey::FileKey, det::DetectorIdLike, process::String; kwargs...)\nget_plottitle(setup::ExpSetupLike, partition::DataPartitionLike, category::DataCategoryLike, det::DetectorIdLike, process::String; additiional_type::String=\"\")\n\nGet the title for a plot.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_pltfilename","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_pltfilename","text":"get_pltfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol)\nget_pltfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike, process::Symbol)\nget_pltfilename(data::LegendData, partition::DataPartitionLike, setup::ExpSetupLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol)\n\nGet the filename for the plot file for a given setup, period, run, category, channel and process.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.get_pltfolder","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.get_pltfolder","text":"get_pltfolder(data::LegendData, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, process::Symbol)\nget_pltfolder(data::LegendData, filekey::FileKey, process::Symbol)\nget_pltfolder(data::LegendData, partition::DataPartitionLike, category::DataCategoryLike, process::Symbol)\n\nGet the folder for the plot files for a given period, run, category and process.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.load_hitchfile-Tuple{Function, LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, Union{ChannelId, AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.load_hitchfile","text":"load_hitchfile(open_func::Function, data::LegendData, (period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike), ch::ChannelIdLike; append_filekeys::Bool=true, calibrate_energy::Bool=false, load_level::String=\"dataQC\")\nload_hitchfile(open_func::Function, data::LegendData, filekey::FileKey, ch::ChannelIdLike; kwargs...)\n\nLoad data from a hitch file for a given channel.\n\nArguments\n\nopen_func::Function: function to open a file\ndata::LegendData: data object\nsetup::ExpSetupLike: setup\nperiod::DataPeriodLike: period\nrun::DataRunLike: run\ncategory::DataCategoryLike: category\nch::ChannelIdLike: channel\nappend_filekeys::Bool=true: append filekey to data for each event\ncalibrate_energy::Bool=false: calibrate energy with given energy calibration parameters\nload_level::String=\"dataQC\": load level\n\nReturn\n\nTable: data table for given hit file\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.load_rawevt","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.load_rawevt","text":"load_rawevt(open_func::Function, data::LegendData, ch::ChannelIdLike, data_hit::Table, sel_evt::Int)\nload_rawevt(open_func::Function, data::LegendData, ch::ChannelIdLike, data_hit::Table, sel_evt::UnitRange{Int})\n\nLoad data for a channel from a hitch file for a given selected event index or index range.\n\nArguments\n\nopen_func::Function: function to open a file\ndata::LegendData: data object\nch::ChannelIdLike: channel\ndata_hit::Table: hitch data\nsel_evt::Int/UnitRange{Int}: selected event index\n\nReturn\n\nTable: data table of raw events\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.load_runch-Tuple{Function, Function, LegendData, Vector{FileKey}, DataTierLike, Union{ChannelId, AbstractString}}","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.load_runch","text":"load_runch(open_func::Function, flatten_func::Function, data::LegendData, filekeys::Vector{FileKey}, tier::DataTierLike, ch::ChannelIdLike; check_filekeys::Bool=true)\n\nLoad data for a channel from a list of filekeys in a given tier.\n\nArguments\n\nopen_func::Function: function to open a file\nflatten_func::Function: function to flatten data\ndata::LegendData: data object\nfilekeys::Vector{FileKey}: list of filekeys\ntier::DataTierLike: tier to load data from\nch::ChannelIdLike: channel to load data for\ncheck_filekeys::Bool=true: check if filekeys are valid\n\n\n\n\n\n","category":"method"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.savelfig","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.savelfig","text":"savelfig(save_func::Function, p, data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol; kwargs...)\nsavelfig(save_func::Function, p, data::LegendData, filekey::FileKey, ch::ChannelIdLike, process::Symbol; kwargs...)\nsavelfig(save_func::Function, p, data::LegendData, partition::DataPartitionLike, setup::ExpSetupLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol; kwargs...)\n\nSave a lplot.\n\n\n\n\n\n","category":"function"},{"location":"packages/LegendDataManagement/#LegendDataManagement.LDMUtils.writevalidity","page":"LegendDataManagement","title":"LegendDataManagement.LDMUtils.writevalidity","text":"writevalidity(props_db::LegendDataManagement.PropsDB, filekey::FileKey; apply_to::Symbol=:all)\nwritevalidity(props_db::LegendDataManagement.PropsDB, filekey::FileKey, part::DataPartitionLike; apply_to::Symbol=:all)\n\nWrite validity for a given filekey.\n\n\n\n\n\n","category":"function"},{"location":"#Juleana.jl","page":"Home","title":"Juleana.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Juleana.jl provides a Julia implementation of LEGEND global event analysis tools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Juleana is a meta package that represents the LEGEND Julia software stack. This stack comprises (mainly) the following Julia packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"LegendDataManagement\nLegendDataTypes\nLegendHDF5IO\nLegendTextIO\nLegendDSP\nLegendSpecFits\nLegendEventAnalysis\nLegendTestData\nRadiationDetectorSignals\nRadiationDetectorDSP\nSolidStateDetectors\nBAT","category":"page"},{"location":"","page":"Home","title":"Home","text":"Juleana depends on, imports and exports all the packages listed above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(As a consequence, any breaking version change in one of these package has to result in a breaking version change of the Juleana package itself.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"So one can, for example, do (but see caveats below)","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Juleana\n\ndata = LegendDataManagement.LegendData(:l200)\n\nusing LegendHDF5IO\ninput = lh5open(...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"without (in this example) import LegendDataManagement and without adding LegendDataManagement and LegendHDF5IO to the dependencies (Project.toml) of the active project.","category":"page"},{"location":"","page":"Home","title":"Home","text":"But: note that this approach is intended only for easy interactive exploration of the LEGEND Julia software stack and for convenient use in scripts and notebooks! Also note that due to it's heavy dependencies, using Juleana will result in longer load times than using only the individual packages that you need.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This approach must not be used in packages. Packages must not depend on Juleana at all, instead packages must only and directly depend on the packages they use! using Juleana and import Juleana have no place in package code and Juleana should never be added to package Project.toml files.","category":"page"},{"location":"assets/README/#Juleana-logo","page":"Juleana logo","title":"Juleana logo","text":"","category":"section"},{"location":"assets/README/","page":"Juleana logo","title":"Juleana logo","text":"The Juleana logo is available here in various formats.","category":"page"},{"location":"assets/README/","page":"Juleana logo","title":"Juleana logo","text":"The master (editable) logo file is \"juleana-logo-inkscape.svg\", it requires the Julia font \"TamilMN-Bold.ttf\" (not included here, but available at https://github.com/JuliaLang/julia-logo-graphics).","category":"page"}]
}
